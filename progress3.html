<!DOCTYPE html>
<html>

<head>
    <title>js overlay</title>
    <meta charset="UTF-8">
    <link rel="icon" href="data:," type="image/x-icon">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.10.4/gsap.min.js"></script>
    <style>
        /* Existing CSS */
        #container {
            position: absolute;
            width: 1280px;
            height: 720px;
            margin: auto;
            top: 0;
            left: 0;
        }

        #qr-code {
            position: absolute;
            top: 2px;
            right: 5px;
            background-color: white;
            width: 120px;
            height: 120px;
            border-top-left-radius: 12px;
            border-top-right-radius: 12px;
            z-index: 3;
        }

        #sats_left {
            position: absolute;
            top: 121px;
            right: 5px;
            width: 120px;
            padding-bottom: 3px;
            text-align: center;
            font-size: 12px;
            font-weight: bold;
            font-family: 'Arial', sans-serif;
            background-color: white;
            border-bottom-left-radius: 12px;
            border-bottom-right-radius: 12px;
            z-index: 3;
        }

        #content {
            position: absolute;
            bottom: 0;
            left: 0;
            width: 100%;
        }

        #progress-container {
            width: 98%;
            height: 11px;
            background-color: #ccc;
            border-radius: 7px;
            position: relative;
            margin: 0 auto;
            z-index: 2;
        }

        #progress-fill {
            height: 100%;
            background-color: #e6b800;
            border-radius: 7px;
            width: 0%;
            /* Ensure initial width is 0 */
        }

        p {
            font-size: 18px;
        }

        #goal-banner {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background-color: #e6b800;
            padding: 10px;
            font-size: 24px;
            font-weight: bold;
            border: 2px solid black;
            border-radius: 12px;
        }

        .scrolling-comment {
            font-size: 12px;
            font-family: 'Arial', sans-serif;
            font-weight: bold;
            color: #FFF;
            padding: 2px;
            position: absolute;
            white-space: nowrap;
            bottom: 0px;
            right: 0;
            z-index: 1;
        }

        #progress-text {
            position: absolute;
            top: 0px;
            /* Adjusted to be above the progress bar */
            width: 100%;
            text-align: center;
            font-size: 9px;
            font-family: 'Arial', sans-serif;
            font-weight: bold;
            line-height: 11px;
            color: #000;
            z-index: 3;
        }

        #goal-achieved-layer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: #e6b800;
            opacity: 0.6;
            z-index: 1;
        }

        #feeder-triggered {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 32px;
            font-weight: bold;
            font-family: 'Arial', sans-serif;
            color: #FFF;
            padding: 10px;
            border-radius: 12px;
            z-index: 2;
        }

        #time-temperature-container {
            position: absolute;
            bottom: 0px;
            left: 0px;
            display: block;
            align-items: center;
            color: white;
            background-color: #e33502;
            border-radius: 7px;
            padding: 2px;
            padding-left: 14px;
            padding-right: 14px;
            /* Added padding to the right */
            font-size: 12px;
            font-weight: bold;
            font-family: 'Arial', sans-serif;
            z-index: 2;
        }

        #current-time,
        #current-temperature {
            display: inline-block;
            margin-right: 10px;
        }

        #bottom-container {
            background-color: #e33502;
            padding: 6px;
            position: absolute;
            bottom: 0;
            left: 0;
            margin: auto;
            height: 26px;
            width: 100%;
            z-index: 0;
        }

        @keyframes scroll {
            0% {
                transform: translateX(0);
            }

            100% {
                transform: translateX(calc(-100% - 1280px));
            }
        }

        .scroll-animation {
            animation: scroll linear forwards;
        }

        /* New CSS for Horizontal Accordion */
        #accordion-container {
            position: absolute;
            top: 3px;
            left: 3px;
            bottom: 3px;
            height: 120px;
            background-color: transparent;
            display: flex;
            overflow: hidden;
            /* Hide overflow to prevent scroll bars */
            z-index: 10;
            opacity: 0;
            /* Initially hidden */
            transform: translateX(-100%);
            /* Initially off-screen to the left */
        }

        .accordion-item {
            background-color: #e33502;
            width: 120px;
            height: 120px;
            /* Fixed size */
            position: relative;
            /* Add relative positioning */
        }

        .accordion-content {
            background-color: #e33502;
            height: 100%;
            /* Adjust height to fill the container */
            display: flex;
            /* Use flexbox for layout */
            flex-direction: column;
            /* Arrange items in a column */
            justify-content: flex-end;
            /* Align items at the bottom */
            opacity: 0;
            /* Hide opacity initially */
        }

        .accordion-content img {
            height: 110px;
            width: 110px;
            display: block;
            margin: auto;
        }

        /* New CSS for Lightning Effect */
        #lightning-effect {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: white;
            opacity: 0;
            z-index: 5;
            display: none;
        }
    </style>
</head>

<body>
    <div id="container">
        <div id="goal-achieved-layer" style="display: none;"></div>
        <div id="feeder-triggered" style="display: none;">Feeder Triggered</div>
        <div id="qr-code">
            <img src="images/qr.png" width='120' height='120' style="border-radius: 12px;">
            <img id="lightning-img" src="images/lightning.png" width='117' height='117'
                style="border-radius: 12px; display: none;">
        </div>
        <div id="sats_left"></div>
        <div id="content">
            <div id="bottom-container">
                <div id="progress-container">
                    <div id="progress-fill"></div>
                    <div id="progress-text"></div>
                </div>
                <div id="time-temperature-container">
                    <div id="current-time"></div>
                    <div id="current-temperature"></div>
                </div>
                <div id="scrolling-comment"></div>
            </div>
        </div>
        <!-- Accordion Container -->
        <div id="accordion-container" style="display: none;"></div>
        <!-- Lightning Effect Overlay -->
        <div id="lightning-effect"></div>
    </div>

    <script>
        let balance = 0;
        let goal = 0;
        let lastSuccessfulGoal = 0;
        let lastSuccessfulBalance = 0;
        let goalAchieved = false;
        let isAnimating = false;
        let messageQueue = [];
        let isScrolling = false;
        let accordionTimeout = null;
        let processedPaymentHashes = new Set();
        const reconnectInterval = 30000;
        const bottomContainer = document.getElementById('bottom-container');

        // Goat information
        const goats = {
            "Newton": { img: "images/newton.png" },
            "Nova": { img: "images/nova.png" },
            "Cosmo": { img: "images/cosmo.png" },
            "Dexter": { img: "images/dexter.png" },
            "Rowan": { img: "images/rowan.png" }
        };

        function fetchConversionRate() {
            return fetch('https://lightning-goats.com/convert/0.01')
                .then(response => {
                    if (!response.ok) {
                        throw new Error(`HTTP error! status: ${response.status}`);
                    }
                    return response.text();
                })
                .catch(error => {
                    console.error('Error fetching conversion rate:', error);
                });
        }

        function fetchAndDisplayMessages(info = false) {
            let url = "https://lightning-goats.com/messages";
            if (info === true) {
                url += "/info";
            }

            fetch(url)
                .then(response => response.json())
                .then(data => {
                    if (Array.isArray(data)) {
                        data.forEach(message => {
                            let processedMessage = message.content
                                .replace(/[\r\n]+/g, ' ')
                                .replace(/\s+/g, ' ')
                                .replace(/https?:\/\/\S+/g, '') // Remove URLs
                                .trim();
                            addMessageToQueue(processedMessage);
                        });
                        resetAllMessages(); // Reset messages after adding to queue
                    } else {
                        console.log("Unexpected data format received:", data);
                    }
                })
                .catch(error => {
                    console.log("Error fetching messages: ", error);
                });
        }

        function resetAllMessages() {
            return fetch('https://lightning-goats.com/messages/reset')
                .then(response => {
                    if (!response.ok) {
                        throw new Error(`HTTP error! status: ${response.status}`);
                    }
                    return response.text();
                })
                .catch(error => {
                    console.error('Error resetting messages:', error);
                });
        }

        function periodicallyUpdate() {
            checkFeederStatus().then(isFeederOn => {
                if (!isFeederOn) {
                    Promise.all([fetchBalance(), fetchGoal()])
                        .then(() => {
                            updateSatsLeftText();
                            updateProgressBar();

                            if (Math.random() < 0.005) {
                                fetchAndDisplayMessages(true); // Display informational message
                            }
                        })
                        .catch(error => {
                            console.log("Error updating sats left and goal: ", error);
                        });
                }
            });
            fetchTemperature();
        }

        function debounce(func, wait) {
            let timeout;
            return function (...args) {
                const later = () => {
                    clearTimeout(timeout);
                    func(...args);
                };
                clearTimeout(timeout);
                timeout = setTimeout(later, wait);
            };
        }

        const debouncedCheckFeederStatus = debounce(checkFeederStatus, 1000);

        function checkFeederStatus() {
            return fetch('https://lightning-goats.com/feeder_status')
                .then(response => response.text())
                .then(isFeederOn => {
                    const feederStatus = isFeederOn.trim() === 'true';
                    const satsLeftElem = document.getElementById('sats_left');
                    if (feederStatus) {
                        satsLeftElem.innerText = "Feeder paused";
                    }
                    return feederStatus;
                })
                .catch(error => {
                    console.error('Failed to fetch feeder status:', error);
                    document.getElementById('sats_left').innerText = "Status error! Check connection.";
                    return false;
                });
        }

        function initWebSocket() {
            const ws = new WebSocket('wss://lnb.bolverker.com/api/v1/ws/036ad4bb0dcb4b8c952230ab7b47ea52');

            ws.onopen = function () {
                console.log("WebSocket connection opened.");
            };

            ws.onerror = function (error) {
                console.log("WebSocket connection error: ", error);
                setTimeout(initWebSocket, reconnectInterval);
            };

            ws.onmessage = function (event) {
                console.log("Payment received event: ", event.data);
                const data = JSON.parse(event.data);

		// Update balance and goal                                                                                     
                balance = data.wallet_balance;
                goal = Math.floor(data.payment.extra.wallet_fiat_rate);

                console.log(`Updated balance to ${balance}`);
                console.log(`Updated goal (wallet_fiat_rate) to ${goal}`);

		checkFeederStatus().then(isFeederOn => {
                    if (!isFeederOn) {
                        const receivedAmount = data.payment.amount / 1000;
                            const currentSatsLeft = goal - balance;

                            if (receivedAmount > 0) {
                                updateSatsLeftElem(receivedAmount, currentSatsLeft, true);
                                toggleQRCodeImage(); // Call the new function here

                                updateProgressBar();

                                fetchConversionRate().then(limit => {
                                    setTimeout(() => {
                                        updateSatsLeftElem(receivedAmount, currentSatsLeft, false);
                                    }, 2000);

                                    fetchAndDisplayMessages(); // Fetch messages when payment is received
                                }).catch(error => {
                                    console.error('Error fetching conversion rate:', error);
                                });
                            }
                    }
                });
            };

            ws.onclose = function () {
                console.log("WebSocket connection closed. Reconnecting...");
                setTimeout(initWebSocket, reconnectInterval);
            };
        }

        document.addEventListener('DOMContentLoaded', function () {
            Promise.all([fetchGoal(), fetchBalance()])  // Removed fetchSpotsRemaining
                .then(() => {
                    updateProgressBar();
                    updateSatsLeftText();
                })
                .catch(error => {
                    console.log("An error occurred:", error);
                });

            initWebSocket();  // Initialize the WebSocket connection
            const updateInterval = 30000;
            setInterval(periodicallyUpdate, updateInterval);
            setInterval(updateCurrentTime, 1000); // Call updateCurrentTime directly to update every second
            setInterval(debouncedCheckFeederStatus, 1000);
            fetchTemperature();
            setInterval(fetchTemperature, updateInterval);
            fetchAndDisplayMessages(); // Fetch messages initially
            setInterval(fetchAndDisplayMessages, 1000);
        });

        function fetchGoal() {
            return new Promise((resolve, reject) => {
                fetch("https://lightning-goats.com/trigger_amount")
                    .then(response => response.json())
                    .then(data => {
                        const newGoal = parseFloat(data.trigger_amount);
                        if (!isNaN(newGoal)) {
                            lastSuccessfulGoal = newGoal;
                            goal = newGoal;
                            resolve();
                        } else {
                            reject(new Error("Invalid trigger amount received"));
                            console.error("Invalid trigger amount received");
                            goal = lastSuccessfulGoal;
                        }
                    })
                    .catch(error => {
                        reject(new Error("Failed to fetch trigger amount"));
                        console.error('Error fetching goal:', error);
                        goal = lastSuccessfulGoal;
                    });
            });
        }

        function fetchBalance() {
    return new Promise((resolve, reject) => {
        fetch("https://lightning-goats.com/balance")
            .then(response => {
                if (!response.ok) {
                    throw new Error(`HTTP error! status: ${response.status}`);
                }
                return response.json();  // Parse the response as JSON
            })
            .then(data => {
                if (data && typeof data.balance === 'number' && data.balance >= 0) {
                    balance = Math.round(data.balance);  // Extract and round the balance
                    resolve();
                } else {
                    console.error("Invalid balance data received:", data);
                    reject(new Error("Invalid balance data received"));
                }
            })
            .catch(error => {
                console.error("Error fetching balance:", error);
                reject(new Error("Failed to fetch balance"));
            });
    });
}


        function updateSatsLeftElem(receivedAmount, currentSatsLeft, toggle) {
            const satsLeftElem = document.getElementById('sats_left');
            if (toggle) {
                satsLeftElem.innerText = `${receivedAmount} sats received`;
            } else {
                if (currentSatsLeft > 0) {
                    satsLeftElem.innerText = `${currentSatsLeft} sats to go`;
                }
            }
        }

        function updateSatsLeftText() {
            let satsLeft = Math.round(Math.max(goal - balance, 0));
            if (satsLeft === 0) {
                if (lastSuccessfulBalance > 0 && lastSuccessfulGoal > 0) {
                    satsLeft = Math.round(Math.max(lastSuccessfulGoal - lastSuccessfulBalance, 0));
                }
            }
            document.getElementById('sats_left').innerText = `${satsLeft} sats to go`;
        }

        function updateProgressBar() {
            if (goal === 0) {
                return;
            }

            const progress = Math.min(Math.max((balance / goal) * 100, 0), 100);
            gsap.to("#progress-fill", { width: `${progress}%`, duration: 2 });
            document.getElementById('progress-text').innerText = `${Math.round(progress)}%`;

            if (progress >= 100 && !goalAchieved && !isAnimating) {
                goalAchieved = true;
                isAnimating = true;

                gsap.to("#goal-achieved-layer", { display: 'block', opacity: 0.7, duration: 0.25 });
                gsap.to("#feeder-triggered", { display: 'block', opacity: 1, duration: 0.5 });

                triggerLightningEffect(); // Call the lightning effect function here

                setTimeout(() => {
                    gsap.to("#goal-achieved-layer", { display: 'none', opacity: 0, duration: 0.5 });
                    gsap.to("#feeder-triggered", {
                        display: 'none',
                        opacity: 0,
                        duration: 0.5,
                        onComplete: () => {
                            isAnimating = false;
                        }
                    });
                }, 500);
            } else if (progress < 100) {
                goalAchieved = false;
                processedPaymentHashes.clear(); // Clear processed payment hashes when progress is below 100%
            }
        }

        function triggerLightningEffect() {
            const lightningEffect = document.getElementById('lightning-effect');
            const feederTriggeredText = document.getElementById('feeder-triggered');

            gsap.set(lightningEffect, { display: 'block', opacity: 0 });

            gsap.timeline()
                .to([lightningEffect, feederTriggeredText], {
                    opacity: 1,
                    duration: 0.1,
                    repeat: 2,
                    yoyo: true,
                    onStart: () => feederTriggeredText.style.color = '#000', // Invert text color to black
                    onComplete: () => feederTriggeredText.style.color = '#FFF' // Revert text color to white
                }) // Flash effect
                .to(lightningEffect, { display: 'none', opacity: 0, duration: 0, onComplete: fetchBalance });
        }

        function fetchTemperature() {
            fetch('https://lightning-goats.com/get_received_data')
                .then(response => response.json())
                .then(data => {
                    if (data && data.AmbientWeatherWS2902A_WeatherDataWs2902a_Temperature) {
                        let temperature = data.AmbientWeatherWS2902A_WeatherDataWs2902a_Temperature.toString();
                        document.getElementById('current-temperature').innerText = `${temperature}°F`;
                    } else {
                        console.error('Invalid temperature data received:', data);
                    }
                })
                .catch(error => {
                    console.error('Error fetching temperature:', error);
                });
        }

        function updateCurrentTime() {
            const now = new Date();
            const formattedTime = now.toLocaleTimeString();
            document.getElementById('current-time').innerText = `${formattedTime}`;
        }

        function addMessageToQueue(messageText) {
            messageQueue.push(messageText);
            if (!isScrolling) {
                displayNextMessage();
            }
        }

        function displayNextMessage() {
            if (messageQueue.length > 0 && !isScrolling) {
                const messageText = messageQueue.shift();
                addScrollingComment(messageText);
            }
        }

        function addScrollingComment(commentText) {
            if (isScrolling) {
                return;
            }

            isScrolling = true;
            const commentDiv = document.createElement('div');
            commentDiv.className = 'scrolling-comment';
            commentDiv.innerText = commentText;

            const bottomContainer = document.getElementById('bottom-container');
            bottomContainer.appendChild(commentDiv);

            commentDiv.style.right = `-${commentDiv.offsetWidth}px`;

            const commentWidth = commentDiv.offsetWidth;
            const containerWidth = bottomContainer.offsetWidth;
            const totalTranslation = commentWidth + containerWidth;

            const scrollSpeed = 100;
            const scrollDuration = totalTranslation / scrollSpeed;

            // Show accordion while message scrolls
            const hasGoatNames = checkForGoatNames(commentText);

            gsap.to(commentDiv, {
                x: -totalTranslation,
                duration: scrollDuration,
                ease: "linear",
                onComplete: () => {
                    bottomContainer.removeChild(commentDiv);
                    isScrolling = false;
                    if (messageQueue.length > 0) {
                        displayNextMessage();
                    }
                    if (!hasGoatNames && accordionTimeout === null) {
                        gsap.to("#accordion-container", {
                            x: '-100%',
                            opacity: 0,
                            duration: 1,
                            onComplete: () => {
                                gsap.set("#accordion-container", { display: 'none' });
                            }
                        }); // Retract accordion when scrolling ends
                    }
                }
            });
        }

        function toggleQRCodeImage() {
            const qrCode = document.querySelector('#qr-code img:first-child');
            const lightningImg = document.getElementById('lightning-img');

            // Hide the QR code and show the lightning image
            gsap.to(qrCode, {
                duration: 0.125, opacity: 0, onComplete: () => {
                    qrCode.style.display = 'none';
                    lightningImg.style.display = 'block';
                    gsap.to(lightningImg, { duration: 0.125, opacity: 1 });
                }
            });

            // Hide the lightning image and show the QR code after 2 seconds
            setTimeout(() => {
                gsap.to(lightningImg, {
                    duration: 0.5, opacity: 0, onComplete: () => {
                        lightningImg.style.display = 'none';
                        qrCode.style.display = 'block';
                        gsap.to(qrCode, { duration: 0.5, opacity: 1 });
                    }
                });
            }, 2000);
        }

        function updateTextWithGSAP(element, newText, duration = 0.5) {
            gsap.to(element, {
                duration: duration / 2,
                opacity: 0,
                onComplete: () => {
                    element.innerText = newText;
                    gsap.to(element, { duration: duration / 2, opacity: 1 });
                }
            });
        }

        function checkForGoatNames(messageText) {
            const goatNames = Object.keys(goats);
            const matchedGoats = [];

            // Extract the order of goat names as they appear in the message
            goatNames.forEach(name => {
                if (messageText.includes(name)) {
                    const index = messageText.indexOf(name);
                    matchedGoats.push({ name, index });
                }
            });

            // Sort the matched goats based on their order in the message
            matchedGoats.sort((a, b) => a.index - b.index);

            const accordionContainer = document.getElementById('accordion-container');
            accordionContainer.innerHTML = ""; // Clear previous content

            if (matchedGoats.length > 0) {
                matchedGoats.forEach(({ name }) => {
                    const goat = goats[name];
                    const item = document.createElement('div');
                    item.className = 'accordion-item';

                    const content = document.createElement('div');
                    content.className = 'accordion-content';

                    const img = document.createElement('img');
                    img.src = goat.img;
                    img.alt = name;

                    content.appendChild(img);
                    item.appendChild(content);

                    accordionContainer.appendChild(item);

                    // Only change opacity of the content
                    gsap.to(content, { opacity: 1, duration: 1 }); // Slower animation
                });

                // GSAP animation for sliding in the accordion container from the left
                gsap.set(accordionContainer, { display: 'flex', x: '-100%' });
                const containerWidth = accordionContainer.scrollWidth;
                gsap.to(accordionContainer, { x: 0, opacity: 1, duration: 1, width: containerWidth });

                // Clear any previous accordion timeout
                if (accordionTimeout !== null) {
                    clearTimeout(accordionTimeout);
                    accordionTimeout = null;
                }

                // Ensure accordion stays visible for a fixed duration
                accordionTimeout = setTimeout(() => {
                    gsap.to(accordionContainer, {
                        x: '-100%',
                        opacity: 0,
                        duration: 1,
                        onComplete: () => {
                            gsap.set("#accordion-container", { display: 'none' });
                        }
                    });
                    accordionTimeout = null;
                }, 18000); // Duration set to 12 seconds
                return true;
            }
            return false;
        }
    </script>
</body>

</html>
