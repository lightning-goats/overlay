<!DOCTYPE html>
<html>
<head>
  <title>js overlay</title>
  <meta charset="UTF-8">
  <link rel="icon" href="data:," type="image/x-icon">
  <style>
    /* General Styles */
    body {
      margin: 0;
      padding: 0;
      font-family: 'Arial', sans-serif;
    }
    
    #container {
      position: absolute;
      width: 1920px; /* scaled from 1280px */
      height: 1080px; /* scaled from 720px */
      margin: auto;
      top: 0;
      left: 0;
    }
    
    /* QR-code container with all rounded corners */
    #qr-code {
      position: absolute;
      top: 3px; /* scaled from 2px */
      right: 8px; /* scaled from 5px */
      background-color: white;
      width: 180px; /* scaled from 120px */
      height: 180px; /* scaled from 120px */
      border-radius: 18px; /* all corners rounded */
      z-index: 3;
    }
    
    #sats-received-overlay {
      position: absolute;
      bottom: 10px;
      left: 50%;
      transform: translateX(-50%);
      font-size: 18px;
      font-weight: bold;
      font-family: 'Arial', sans-serif;
      color: black;
      background-color: transparent;
      pointer-events: none;
      z-index: 4;
      opacity: 0;
      white-space: nowrap;
    }
    
    #content {
      width: 100%;
      display: flex;
      justify-content: center;
      align-items: center;
      flex-direction: column;
    }
    
    /* Top-left container for feedings, spots remaining and sats_left all in one row */
    #top-left-container {
      display: flex;
      flex-direction: row; /* place all children in one row */
      align-items: center;
      background-color: #000000;
      border-radius: 18px;
      padding: 5px 9px;
      position: absolute;
      top: 5px;
      left: 5px;
      box-sizing: border-box;
      z-index: 0;
    }
    
    /* Individual top-left elements */
    #goat-feedings,
    #spots-remaining,
    #sats_left {
      color: white;
      font-weight: bold;
      font-size: 18px;
      font-family: 'Arial', sans-serif;
      margin-right: 10px;
    }
    
    #bottom-container {
      display: flex;
      align-items: center;
      background-color: #e33502;
      border-radius: 18px;
      padding: 5px 9px;
      position: absolute;
      bottom: 0;
      left: 0;
      width: 100%;
      box-sizing: border-box;
      z-index: 0;
    }
    
    #time-temperature-container {
      flex-shrink: 0;
      display: flex;
      align-items: center;
      background-color: #e33502;
      border-radius: 11px;
      padding: 5px 9px;
      font-size: 18px;
      font-weight: bold;
      font-family: 'Arial', sans-serif;
      color: white;
      z-index: 2;
    }
    
    #current-time,
    #current-temperature {
      margin-right: 8px;
    }
    
    /* Wallet balance display (if used) */
    #wallet-balance {
      margin-left: 8px;
    }
    
    #center-container {
      flex-grow: 1;
      display: flex;
      justify-content: center;
      position: relative;
    }
    
    #progress-container {
      position: relative;
      width: 99%;
      height: 20px;
      background-color: #e6e6e6;
      border-radius: 11px;
      overflow: hidden;
      z-index: 2;
    }
    
    #progress-fill {
      height: 100%;
      background-color: #e6b800;
      border-radius: 11px;
      width: 0%;
      z-index: 1;
    }
    
    #progress-text {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      text-align: center;
      font-size: 15px;
      font-family: 'Arial', sans-serif;
      font-weight: bold;
      line-height: 20px;
      color: #000;
      z-index: 3;
      white-space: nowrap;
      overflow: hidden;
      pointer-events: none;
      display: flex;
      align-items: center;
      justify-content: center;
    }
    
    #scrolling-comment {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      z-index: 4;
      overflow: hidden;
      pointer-events: none;
    }
    
    #scrolling-comment .message {
      position: absolute;
      white-space: nowrap;
      font-size: 18px;
      font-weight: bold;
      color: #000;
      border-radius: 8px;
      will-change: transform;
      transform: translate3d(0, -50%, 0);
    }
    
    /* Vertical accordion container for goat images */
    #accordion-container {
      position: absolute;
      top: 50px; /* Position at top area of screen */
      left: 8px; /* Position at left edge instead of right */
      width: auto; /* Auto width to accommodate horizontal layout */
      height: auto; /* Auto height */
      background-color: transparent;
      display: flex;
      flex-direction: row;  /* Horizontal layout instead of column */
      overflow: hidden;
      z-index: 3;
      opacity: 0;
      transform: translateX(-100%); /* Move off-screen to the left for animation */
    }
    
    .accordion-item {
      background-color: #000000;
      width: 130px; /* Narrower to fit more items */
      height: 190px; /* Increased height to accommodate all content */
      position: relative;
      margin-right: 10px; /* Add spacing between items */
      border-radius: 18px; /* Add rounded corners to items */
      overflow: hidden; /* Ensure content stays within rounded corners */
    }
    
    /* All accordion items use the same height */
    .accordion-item.user-profile {
      height: 190px; /* Match regular item height */
    }
    
    .accordion-content {
      background-color: #000000;
      height: 100%;
      display: flex;
      flex-direction: column; /* Changed to column to stack image and text */
      justify-content: flex-start; /* Changed from center to top-align content */
      opacity: 0;
      padding: 10px 5px; /* Add some extra padding at top/bottom */
      align-items: center;
      border-radius: 18px; /* Match item border radius */
    }
    
    .accordion-content img {
      height: 100px;
      width: 100px;
      display: block;
      margin-top: 10px; /* Add some space at the top */
      margin-bottom: 8px; /* Space between image and text */
      border-radius: 50%; /* Makes the image circular */
      object-fit: cover; /* Ensures the image covers the area without distortion */
      border: 2px solid white; /* Add a white border around the circular image */
      box-shadow: 0 4px 8px rgba(0,0,0,0.2); /* Add subtle shadow */
    }
    
    /* Optional: Add a subtle breathing animation to highlight user profiles */
    @keyframes breathe {
      0% { transform: scale(1); }
      50% { transform: scale(1.05); }
      100% { transform: scale(1); }
    }
    
    /* Only apply breathing effect to the newest member */
    [data-newest="true"] .accordion-content img {
      animation: breathe 3s infinite ease-in-out;
    }

    /* Enhanced user profile styling */
    .user-profile-container {
      display: flex;
      flex-direction: column; /* Changed to column to stack image and text */
      align-items: center;
      justify-content: flex-start; /* Changed to align content to top */
      text-align: center; /* Center text under image */
      width: 100%;
      padding: 0 5px;
      box-sizing: border-box;
    }
    
    .user-profile-text {
      width: 100%;
      display: flex;
      flex-direction: column;
      justify-content: flex-start; /* Align text to top */
      align-items: center;
      margin-top: 5px; /* Space between image and text */
    }
    
    .user-profile-name {
      color: white;
      font-weight: bold;
      font-size: 12px;
      overflow: hidden;
      text-overflow: ellipsis;
      max-width: 120px;
      white-space: nowrap;
      text-align: center;
    }
    
    .user-profile-kinds {
      color: #ffdb58;
      font-weight: bold;
      font-size: 12px;
      margin-top: 2px;
      overflow: hidden;
      text-overflow: ellipsis;
      max-width: 120px;
      white-space: nowrap;
      display: block; /* Ensure visibility */
      text-align: center;
    }
    
    /* Add styling for zap amount display */
    .user-profile-zap {
      color: #ffdb58;
      font-weight: bold;
      font-size: 12px;
      font-weight: bold;
      margin-top: 2px;
      display: block;
      text-align: center;
    }

    /* Lightning effect styling */
    #lightning-effect {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background-color: #e6b800;
      z-index: 1000;
      pointer-events: none;
      display: none;
      opacity: 0;
    }

    #feeder-triggered {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background-color: rgba(230, 184, 2, 0.6);
            color: white;
            padding: 30px 60px; /* scaled from 20px 40px */
            border-radius: 15px; /* scaled from 10px */
            font-size: 36px; /* scaled from 24px */
            font-weight: bold;
            display: none;
            z-index: 7;
            box-shadow: 0 0 20px rgba(0, 0, 0, 0.5);
        }
  </style>
  <!-- GSAP Library -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.10.4/gsap.min.js" defer></script>
</head>
<body>
  <div id="container">
    <div id="feeder-triggered" style="display: none;">⚡ Feeder Triggered ⚡</div>
    
    <div id="top-left-container">
      <span id="goat-feedings">The goats have been fed 0 times today.</span>
      <span id="spots-remaining"></span>
      <span id="sats_left">⚡0 sats to go until the herd is fed again.⚡</span>
    </div>
    
    <div id="qr-code">
      <img src="images/qr.png" width="180" height="180" style="border-radius: 18px;">
      <img id="lightning-img" src="images/lightning.png" width="177" height="177" style="border-radius: 18px; display: none;">
      <div id="sats-received-overlay"></div>
    </div>
    
    <div id="content">
      <div id="bottom-container">
        <div id="time-temperature-container">
          <div id="current-time">--:--</div>
          <div id="current-temperature">-- °F</div>
        </div>
        <div id="center-container">
          <div id="progress-container">
            <div id="progress-fill"></div>
            <div id="progress-text">0%</div>
            <div id="scrolling-comment"></div>
          </div>
        </div>
      </div>
    </div>
    <div id="accordion-container" style="display: none;"></div>
    <div id="lightning-effect"></div>
  </div>
  <script>
    (function () {
      const RECONNECT_INTERVAL_BASE = 30000; // 30 seconds
      const MAX_RECONNECT_INTERVAL = 60000; // 60 seconds
      const FETCH_INTERVAL = 16000;
      const SATS_LEFT_DISPLAY_DURATION = 2000;
      const WS_URL = 'wss://lnb.bolverker.com/api/v1/ws/036ad4bb0dcb4b8c952230ab7b47ea52';
      const WS_URL_FASTAPI = 'wss://lightning-goats.com/ws/';
      const API_BASE_URL = 'https://lightning-goats.com';
      const MAX_PROCESSED_HASHES = 25;
      const MAX_DISPLAYED_MEMBERS = 10; // Maximum number of CyberHerd members to display
      
      // JSON-based animation and UI configuration
      const animationConfig = {
        message: {
          scrollSpeed: 200,       // Pixels per second for message scrolling
          spacing: 30,            // Spacing between messages in pixels
          separator: " ⚡ ", // Separator between messages
          checkPoints: [0.8, 0.5, 0.3], // Message check points (as percentage of container width)
          separatorColor: "#e33502" // Color of the separator
        },
        accordion: {
          displayDuration: 18000, // How long accordion items stay visible (18 seconds)
          transitionDuration: 1000, // Animation duration for accordion appearance
          breatheAnimationDuration: 3000 // Duration of breathing animation for user profiles
        },
        qrCode: {
          flashDuration: 125,    // Duration of QR code flash animation (ms)
          displayDuration: 2000  // How long to show the lightning image (ms)
        },
        feeder: {
          effectDuration: 2000,  // Duration of feeder triggered effect (ms)
          scalingStart: 0.8,     // Initial scale when animation starts
          scalingEnd: 1.2        // Final scale when animation ends
        },
        lightning: {
          flashDuration: 200,    // Duration of lightning flash (ms)
          flashCount: 3          // Number of lightning flashes
        },
        progressBar: {
          updateDuration: 2000   // Duration of progress bar animation (ms)
        }
      };
      
      const container = document.getElementById('container');
      const feederTriggeredText = document.getElementById('feeder-triggered');
      const qrCode = document.getElementById('qr-code');
      const qrCodeImg = document.querySelector('#qr-code img:first-child');
      const lightningImg = document.getElementById('lightning-img');
      const satsLeftElem = document.getElementById('sats_left');
      const currentTimeElem = document.getElementById('current-time');
      const currentTempElem = document.getElementById('current-temperature');
      const goatFeedingsElem = document.getElementById('goat-feedings');
      const spotsRemainingElem = document.getElementById('spots-remaining');
      const progressFill = document.getElementById('progress-fill');
      const progressText = document.getElementById('progress-text');
      const scrollingComment = document.getElementById('scrolling-comment');
      const satsReceivedOverlay = document.getElementById('sats-received-overlay');
      
      let balance = 0; // in sats
      let goal = 0;
      let lastSuccessfulGoal = 0;
      let lastSuccessfulBalance = 0;
      let isAnimating = false;
      
      // Global variables for message handling
      let messageQueue = [];
      let activeMessages = []; // Track active messages on screen
      let isScrolling = false;
      let messageSpacing = animationConfig.message.spacing; // Use config value for spacing
      let messageCheckInterval = null;
      const MESSAGE_SEPARATOR = animationConfig.message.separator; // Use config value for separator
      
      // CyberHerd members tracking
      let cyberHerdMembers = [];
      
      let reconnectInterval = RECONNECT_INTERVAL_BASE;
      let processedPaymentHashes = new Set();
      
      // Define goat images mapping
      const goats = {
        "Newton": { img: "images/newton.png" },
        "Nova": { img: "images/nova.png" },
        "Cosmo": { img: "images/cosmo.png" },
        "Dexter": { img: "images/dexter.png" },
        "Rowan": { img: "images/rowan.png" }
      };
      
      let accordionTimeout = null;
      
      function debounce(func, wait) {
        let timeout;
        return function (...args) {
          clearTimeout(timeout);
          timeout = setTimeout(() => func.apply(this, args), wait);
        };
      }
      
      function throttle(func, limit) {
        let inThrottle;
        return function (...args) {
          if (!inThrottle) {
            func.apply(this, args);
            inThrottle = true;
            setTimeout(() => inThrottle = false, limit);
          }
        };
      }
      
      function formatTime(date) {
        return date.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' });
      }
      
      const debouncedUpdateProgressBar = debounce(updateProgressBar, 100);
      const throttledUpdateSatsLeft = throttle(updateSatsLeft, 200);
      
      async function fetchData(url, options = {}) {
        try {
          const response = await fetch(url, options);
          if (!response.ok) {
            throw new Error(`Error fetching ${url}: ${response.statusText}`);
          }
          const contentType = response.headers.get('content-type');
          if (contentType && contentType.includes('application/json')) {
            return await response.json();
          }
          return await response.text();
        } catch (error) {
          throw error;
        }
      }
      
      // OPTIMIZE: Use balance/goal from WebSocket instead of separate API calls
      async function fetchGoal() {
        // Only fetch if we don't have a valid goal from WebSocket
        if (goal <= 0) {
          try {
            const data = await fetchData(`${API_BASE_URL}/payments/trigger_amount`);
            const newGoal = parseFloat(data.trigger_amount);
            if (!isNaN(newGoal)) {
              lastSuccessfulGoal = newGoal;
              goal = newGoal;
            } else {
              throw new Error("Invalid trigger amount received");
            }
          } catch (error) {
            goal = lastSuccessfulGoal;
          }
        }
      }
      
      // OPTIMIZE: Use balance from WebSocket instead of separate API calls
      // Keep fetchBalance as a fallback only
      async function fetchBalance() {
        // Only fetch if we need a balance refresh (new session or potential missed WS updates)
        if (balance <= 0) {
          try {
            const data = await fetchData(`${API_BASE_URL}/payments/balance`);
            if (data && typeof data.balance === 'number' && data.balance >= 0) {
              const balanceInSats = Math.round(data.balance / 1000);
              lastSuccessfulBalance = balanceInSats;
              balance = balanceInSats;
            } else {
              balance = lastSuccessfulBalance || 0;
              throw new Error("Invalid balance data received");
            }
          } catch (error) {
            balance = lastSuccessfulBalance || 0;
          }
        }
        updateSatsLeft();
      }
      
      // Keep this as-is since it's used once at startup
      async function fetchFeedings() {
        try {
          const data = await fetchData(`${API_BASE_URL}/goats/feedings`);
          if (data && typeof data.goat_feedings === 'number') {
            const feedings = data.goat_feedings;
            const timeWord = (feedings === 1) ? "time" : "times";
            goatFeedingsElem.innerText = `The ⚡Lightning Goats⚡ have been fed ${feedings} ${timeWord} today.`;
          } else {
            goatFeedingsElem.innerText = '';
          }
        } catch (error) {
          goatFeedingsElem.innerText = '';
        }
      }
      
      // This function is only needed at startup
      async function fetchSpotsRemaining() {
        try {
          const data = await fetchData(`${API_BASE_URL}/cyberherd/spots_remaining`);
          if (data && typeof data.spots_remaining === 'number') {
            const spots = data.spots_remaining;
            spotsRemainingElem.innerText = `CyberHerd spots left: ${spots}`;
          } else {
            spotsRemainingElem.innerText = '';
          }
        } catch (error) {
          spotsRemainingElem.innerText = '';
        }
      }
      
      function addMessageToQueue(text, displayData = null) {
        // Skip empty messages
        if (!text) return;
        
        // Add all messages to queue without duplicate checking
        messageQueue.push({
          text: text,
          displayData: displayData
        });
        
        // Try to display immediately
        tryDisplayMessage();
        
        // Ensure the check interval is running
        if (messageCheckInterval === null) {
          messageCheckInterval = setInterval(tryDisplayMessage, 200);
        }
      }
      
      function tryDisplayMessage() {
        // If queue is empty, clean up and exit
        if (messageQueue.length === 0) {
          if (messageCheckInterval !== null && activeMessages.length === 0) {
            clearInterval(messageCheckInterval);
            messageCheckInterval = null;
          }
          return;
        }

        // Always show a message if there are none active
        if (activeMessages.length === 0) {
          processNextMessage();
          return;
        }

        // Otherwise, check for enough space to display next message
        const containerWidth = scrollingComment.offsetWidth;
        
        // Find the rightmost message edge (the one that entered most recently)
        let newestMessage = activeMessages[activeMessages.length - 1];
        
        // Calculate the actual right edge position (left position + width)
        let newestMessageRightEdge = newestMessage.x + newestMessage.width;
        
        // Check if there's enough space from the container edge
        // We want to make sure the newest message has moved in enough before showing the next one
        const enteredEnough = newestMessageRightEdge <= containerWidth - messageSpacing;
        
        if (enteredEnough) {
          processNextMessage();
        }
      }
      
      function processNextMessage() {
        if (messageQueue.length === 0) return;
        
        // Get the next message from the queue
        const messageItem = messageQueue.shift();
        const messageText = messageItem.text;
        const displayData = messageItem.displayData;
        
        // If this message has display data, show it in the accordion
        if (displayData) {
          displayAccordion(Array.isArray(displayData) ? displayData : [displayData]);
        }
        
        // Create message element
        const containerWidth = scrollingComment.offsetWidth;
        const messageSpan = document.createElement('span');
        messageSpan.className = 'message';
        
        // Add separator before message text if there are already active messages
        const finalMessageText = activeMessages.length > 0 ? 
          MESSAGE_SEPARATOR + messageText : 
          messageText;
        
        messageSpan.innerText = finalMessageText;
        
        // Position at right edge (completely outside the container)
        gsap.set(messageSpan, { 
          x: containerWidth,
          top: '50%', // Ensure it's vertically centered
          y: '-50%'   // Account for the transform in CSS
        });
        scrollingComment.appendChild(messageSpan);
        
        // Hide progress text if first message
        if (activeMessages.length === 0) {
          isScrolling = true;
          progressText.style.display = 'none';
        }
        
        // Process layout then animate
        requestAnimationFrame(() => {
          const messageWidth = messageSpan.offsetWidth;
          const totalDistance = containerWidth + messageWidth;
          const duration = totalDistance / animationConfig.message.scrollSpeed;
          
          // Create tracking object with both left and right edge positions
          const messageTracker = {
            element: messageSpan,
            width: messageWidth,
            x: containerWidth,
            get rightEdge() { return this.x + this.width; },
            initialTimestamp: Date.now()
          };
          
          // Add to active messages
          activeMessages.push(messageTracker);
          
          // Animate the message
          gsap.to(messageSpan, {
            x: -messageWidth,
            duration: duration,
            ease: "linear",
            onUpdate: function() {
              // Update position tracker with precise value
              messageTracker.x = parseFloat(messageSpan._gsap.x);
            },
            onComplete: () => {
              // Clean up message
              const index = activeMessages.findIndex(m => m.element === messageSpan);
              if (index !== -1) {
                activeMessages.splice(index, 1);
              }
              
              if (scrollingComment.contains(messageSpan)) {
                scrollingComment.removeChild(messageSpan);
              }
              
              // Show progress text if no messages left
              if (activeMessages.length === 0) {
                isScrolling = false;
                progressText.style.display = 'flex';
              }
              
              // Try to display another message
              tryDisplayMessage();
            }
          });
        });
      }
      
      function updateSatsLeft(receivedAmount = 0, isNewPayment = false) {
        if (isNewPayment) {
          displayReceivedAmount(receivedAmount);
        } else {
          const currentGoal = typeof goal === 'number' ? goal : 0;
          const currentBalance = typeof balance === 'number' ? balance : 0;
          const satsLeft = Math.max(currentGoal - currentBalance, 0);
          satsLeftElem.innerText = `⚡${satsLeft} sats to go until the herd is fed again.⚡`;
        }
        debouncedUpdateProgressBar();
      }
      
      function displayReceivedAmount(receivedAmount) {
        if (receivedAmount > 0) {
          const overlayText = `${Math.round(receivedAmount)} sats received`;
          satsReceivedOverlay.innerText = overlayText;
          gsap.to(satsReceivedOverlay, { 
            duration: animationConfig.qrCode.flashDuration / 1000, 
            opacity: 1 
          });
          setTimeout(() => {
            gsap.to(satsReceivedOverlay, { duration: 0.5, opacity: 0 });
            updateSatsLeft();
          }, SATS_LEFT_DISPLAY_DURATION);
        } else {
          updateSatsLeft();
        }
      }
      
      function updateProgressBar() {
        if (goal === 0) return;
        const progress = Math.min(Math.max((balance / goal) * 100, 0), 100);
        gsap.to(progressFill, { 
          width: `${progress}%`, 
          duration: animationConfig.progressBar.updateDuration / 1000 // Convert ms to seconds for GSAP
        });
        if (!isScrolling) {
          progressText.innerText = `${Math.round(progress)}%`;
        }
        if (progress >= 100 && !isAnimating) {
          triggerLightningEffect();
          triggerFeederEffect();
          isAnimating = true;
          setTimeout(() => { fetchFeedings(); }, 1000);
        }
      }
      
      function addProcessedPaymentHash(hash) {
        if (processedPaymentHashes.size >= MAX_PROCESSED_HASHES) {
          const firstHash = processedPaymentHashes.values().next().value;
          processedPaymentHashes.delete(firstHash);
        }
        processedPaymentHashes.add(hash);
      }
      
      let ws;
      let currentReconnectInterval = RECONNECT_INTERVAL_BASE;
      
      function initWebSocket() {
        ws = new WebSocket(WS_URL);
        ws.onopen = () => { currentReconnectInterval = RECONNECT_INTERVAL_BASE; };
        ws.onerror = () => {};
        ws.onmessage = async (event) => {
          try {
            const data = JSON.parse(event.data);
            if (data.payment && data.wallet_balance !== undefined) {
              const receivedAmount = data.payment.amount / 1000;
              const walletBalanceSats = data.wallet_balance;
              const paymentHash = (data.payment.payment_hash || '').toLowerCase().trim();
              if (!paymentHash) return;
              if (processedPaymentHashes.has(paymentHash)) return;
              addProcessedPaymentHash(paymentHash);
              balance = walletBalanceSats;
              lastSuccessfulBalance = balance;
              if (receivedAmount > 0) {
                throttledUpdateSatsLeft(receivedAmount, true);
                toggleQRCodeImage();
              } else if (receivedAmount < 0) {
                throttledUpdateSatsLeft();
              }
              setTimeout(() => { fetchFeedings(); }, 1000);
            }
            if (data.message) {
              addMessageToQueue(data.message);
            }
          } catch (error) {}
        };
        ws.onclose = () => {
          setTimeout(() => {
            currentReconnectInterval = Math.min(currentReconnectInterval * 2, MAX_RECONNECT_INTERVAL);
            initWebSocket();
          }, currentReconnectInterval);
        };
      }
      
      let wsFastAPI;
      let reconnectIntervalFastAPI = 30000;
      
      function initWebSocketFastAPI() {
        wsFastAPI = new WebSocket(WS_URL_FASTAPI);
        wsFastAPI.onopen = () => { reconnectIntervalFastAPI = 30000; };
        wsFastAPI.onmessage = (event) => { handleFastAPIWebSocketMessage(event.data); };
        wsFastAPI.onerror = () => {};
        wsFastAPI.onclose = () => {
          setTimeout(initWebSocketFastAPI, reconnectIntervalFastAPI);
          reconnectIntervalFastAPI = Math.min(reconnectIntervalFastAPI * 2, 60000);
        };
      }
      
      // Utility function to clean message text - remove newlines and URLs
      function cleanMessageText(text) {
        if (!text) return '';
        
        // Remove all newlines and carriage returns
        let cleaned = text.replace(/[\r\n]+/g, ' ');
        
        // Remove URLs (http, https, www)
        cleaned = cleaned.replace(/https?:\/\/[^\s]+/g, '');
        cleaned = cleaned.replace(/www\.[^\s]+/g, '');
        
        // Normalize spaces (remove consecutive spaces)
        cleaned = cleaned.replace(/\s+/g, ' ').trim();
        
        return cleaned;
      }

      function handleFastAPIWebSocketMessage(data) {
        try {
          // Attempt to parse as JSON
          const jsonData = JSON.parse(data);
          
          // Single consolidated log for all JSON messages
          console.log(`WebSocket [${jsonData.type || 'unknown'}]:`, jsonData);
          
          // Handle structured JSON message
          if (jsonData.type && jsonData.message) {
            // Skip displaying connection_established messages
            if (jsonData.type === "connection_established") {
              return;
            }
            
            const messageText = jsonData.message;
            const cleanedMessage = cleanMessageText(messageText);
            
            // Handle each message type differently
            switch (jsonData.type) {
              case "cyberherd_user":
                // OPTIMIZE: Use spots directly from message instead of API call
                // Update spots remaining directly from message data
                if (jsonData.data && jsonData.data.spots_remaining !== undefined) {
                  const spots = jsonData.data.spots_remaining;
                  spotsRemainingElem.innerText = `CyberHerd spots left: ${spots}`;
                }
                
                // Process all_members array if available (new format from backend)
                if (jsonData.data && jsonData.data.all_members && Array.isArray(jsonData.data.all_members)) {
                  // Use the full list of members directly from the server
                  cyberHerdMembers = jsonData.data.all_members;
                  
                  // Find the newest member if marked
                  const newestPubkey = cyberHerdMembers.find(m => m.is_newest)?.pubkey || 
                                       (jsonData.data.pubkey || null);
                  
                  // Display all members with newest highlighted
                  displayCyberHerdMembers(cyberHerdMembers, newestPubkey);
                }
                // Fallback to single user data if all_members not available
                else if (jsonData.data && jsonData.data.picture) {
                  let userData = {
                    imageUrl: jsonData.data.picture,
                    name: jsonData.data.display_name || "Anon",
                    isUser: true,
                    kinds: jsonData.data.kinds || "",
                    pubkey: jsonData.data.pubkey || "",
                    amount: jsonData.data.amount || 0,
                    timestamp: Date.now() // Add timestamp for sorting
                  };
                  
                  // Add to cyberherd members (with deduplication by pubkey)
                  const pubkey = userData.pubkey;
                  const existingIndex = cyberHerdMembers.findIndex(member => member.pubkey === pubkey);
                  
                  if (existingIndex >= 0) {
                    // Update existing member with new data but preserve their original timestamp
                    const originalTimestamp = cyberHerdMembers[existingIndex].timestamp;
                    cyberHerdMembers[existingIndex] = { ...userData, timestamp: originalTimestamp };
                  } else {
                    // Add as new member
                    cyberHerdMembers.unshift(userData); // Add to the beginning of the array
                  }
                  
                  // Only keep the most recent members (sorted by timestamp)
                  if (cyberHerdMembers.length > MAX_DISPLAYED_MEMBERS * 2) {
                    cyberHerdMembers = cyberHerdMembers
                      .sort((a, b) => b.timestamp - a.timestamp) // Sort by newest first
                      .slice(0, MAX_DISPLAYED_MEMBERS); // Keep only the top entries
                  }
                  
                  // Show all cyberherd members in accordion, with newest highlighted
                  displayCyberHerdMembers(cyberHerdMembers, pubkey);
                }
                
                // Display the cleaned message in the scrolling area
                addMessageToQueue(cleanedMessage);
                break;
                
              case "payment_event":
              case "feeder_event":
                // OPTIMIZE: Extract and use balance and goal data
                if (jsonData.data) {
                  // Update balance if provided
                  if (jsonData.data.balance !== undefined && jsonData.data.balance !== null) {
                    balance = jsonData.data.balance;
                    lastSuccessfulBalance = balance;
                  }
                  
                  // Update difference/goal data if provided
                  if (jsonData.data.difference !== undefined && jsonData.data.difference !== null) {
                    // Directly update the sats left display with the provided difference
                    satsLeftElem.innerText = `⚡${jsonData.data.difference} sats to go until the herd is fed again.⚡`;
                    
                    // If we have a balance, we can calculate the goal more accurately
                    if (balance > 0) {
                      goal = balance + jsonData.data.difference;
                      lastSuccessfulGoal = goal;
                    }
                  }
                  
                  // Update the progress bar based on the new values
                  debouncedUpdateProgressBar();
                  
                  // Update goat feedings count if included in feeder event
                  if (jsonData.type === "feeder_event" && jsonData.data.goat_feedings !== undefined) {
                    const feedings = jsonData.data.goat_feedings;
                    const timeWord = (feedings === 1) ? "time" : "times";
                    goatFeedingsElem.innerText = `The ⚡Lightning Goats⚡ have been fed ${feedings} ${timeWord} today.`;
                  }
                }
                
                // Prepare goat data if available, but don't display yet
                let goatItems = null;
                if (jsonData.data && jsonData.data.goats && Array.isArray(jsonData.data.goats)) {
                  goatItems = jsonData.data.goats.map(goat => ({
                    imageUrl: goats[goat.name]?.img,
                    name: goat.name,
                    isUser: false
                  })).filter(item => item.imageUrl); // Filter out goats with missing images
                }
                
                // Add the cleaned message to queue with the goat data attached
                addMessageToQueue(cleanedMessage, goatItems);
                break;
                
              // OPTIMIZE: Handle info_message with system stats
              case "info_message":
                // Check if this is a system stats message
                if (jsonData.data && jsonData.data.systemStats) {
                  if (jsonData.data.systemStats.temperature !== undefined) {
                    const temperature = Math.round(jsonData.data.systemStats.temperature);
                    currentTempElem.innerText = `${temperature} °F`;
                  }
                }
                
                // For any message type, display in scrolling area
                addMessageToQueue(messageText);
                break;
                
              case "cyberherd_treats":
              case "legacy":
              default:
                // For any message type, display in scrolling area
                addMessageToQueue(messageText);
            }
          } else {
            // Fallback for JSON objects without type/message format
            console.log("Received JSON without type/message structure:", jsonData);
          }
        } catch (e) {
          // Not JSON, directly add as a message without checking for duplicates
          console.log("WebSocket [non-JSON]:", data, e);
          addMessageToQueue(data);
        }
      }
      
      // Image cache implementation
      class ImageCache {
        constructor(cacheName = 'lg-image-cache-v1') {
          this.cacheName = cacheName;
          this.cacheSupported = 'caches' in window;
          this.loadedImages = new Set(); // Track already loaded images
        }
        
        async initCache() {
          if (!this.cacheSupported) return false;
          try {
            // Open or create the cache
            this.cache = await caches.open(this.cacheName);
            return true;
          } catch (error) {
            console.error('Error initializing cache:', error);
            return false;
          }
        }
        
        async preloadImages(imageUrls) {
          if (!this.cacheSupported || !this.cache) return;
          
          console.log('Preloading images:', imageUrls);
          const cachePromises = imageUrls.map(url => this.cacheImage(url, true));
          
          try {
            await Promise.allSettled(cachePromises);
            console.log('Image preloading complete');
          } catch (error) {
            console.error('Error preloading images:', error);
          }
        }
        
        async cacheImage(url, silent = false) {
          if (!this.cacheSupported || !this.cache || !url) return url;
          if (this.loadedImages.has(url)) return url;
          
          try {
            // Check if already in cache
            const cacheResponse = await this.cache.match(url);
            if (cacheResponse) {
              this.loadedImages.add(url);
              return url;
            }
            
            // Fetch and cache the image
            const fetchResponse = await fetch(url, { mode: 'no-cors', cache: 'no-cache' });
            if (fetchResponse && fetchResponse.status === 200) {
              await this.cache.put(url, fetchResponse.clone());
              this.loadedImages.add(url);
              if (!silent) console.log('Cached image:', url);
            }
            return url;
          } catch (error) {
            if (!silent) console.error('Error caching image:', url, error);
            return url;
          }
        }
        
        async getImage(url) {
          if (!this.cacheSupported || !this.cache || !url) return url;
          
          try {
            // Try to get from cache first
            const cachedResponse = await this.cache.match(url);
            if (cachedResponse) {
              this.loadedImages.add(url);
              return url;
            }
            
            // If not in cache, cache it for next time
            await this.cacheImage(url);
            return url;
          } catch (error) {
            console.error('Error retrieving image from cache:', url, error);
            return url;
          }
        }
        
        // Clean up old cached images (call periodically if needed)
        async cleanCache(maxAgeDays = 7) {
          if (!this.cacheSupported) return;
          
          try {
            const cache = await caches.open(this.cacheName);
            const cachedRequests = await cache.keys();
            const now = Date.now();
            const maxAge = maxAgeDays * 24 * 60 * 60 * 1000;
            
            for (const request of cachedRequests) {
              const response = await cache.match(request);
              if (response) {
                const dateHeader = response.headers.get('date');
                if (dateHeader) {
                  const cacheDate = new Date(dateHeader).getTime();
                  if (now - cacheDate > maxAge) {
                    await cache.delete(request);
                    console.log('Removed old cached image:', request.url);
                  }
                }
              }
            }
          } catch (error) {
            console.error('Error cleaning cache:', error);
          }
        }
      }
      
      // Create global image cache instance
      const imageCache = new ImageCache();
      
      // Collection of all images that should be preloaded
      function getPreloadImageUrls() {
        const urls = [];
        
        // Add goat images
        Object.values(goats).forEach(goat => {
          if (goat.img) urls.push(goat.img);
        });
        
        // Add static UI images
        urls.push('images/qr.png');
        urls.push('images/lightning.png');
        urls.push('images/lightninggoatslogo1.png'); // Fallback image
        
        return urls.filter(Boolean);
      }
      
      // Modified image loading for user profile images
      function createCachedImage(url, alt, title, options = {}) {
        const img = document.createElement('img');
        
        // Handle cached loading
        if (url && imageCache.cacheSupported) {
          // Set a placeholder or loading state
          if (options.placeholder) {
            img.src = options.placeholder;
          }
          
          // Try to load from cache
          imageCache.getImage(url).then(cachedUrl => {
            img.src = cachedUrl;
          }).catch(() => {
            // Fallback if cache fails
            img.src = url;
          });
        } else {
          // Direct loading if caching not supported
          img.src = url;
        }
        
        // Set other attributes
        if (alt) img.alt = alt;
        if (title) img.title = title;
        
        // Setup error handling
        img.onerror = () => {
          img.src = options.fallback || "images/lightninggoatslogo1.png";
          console.log("Image failed to load, using placeholder");
        };
        
        return img;
      }
      
      // Modified displayAccordion to use cached images
      function displayAccordion(items) {
        // Check if these are user items - if so, we've already handled them
        if (items.length > 0 && items[0].isUser) {
          // If these are for cyberherd users, we've already created the display
          // from the displayCyberHerdMembers function
          return true;
        }
        
        // Continue with normal display for goat images and other non-user items
        const accordionContainer = document.getElementById('accordion-container');
        accordionContainer.innerHTML = ""; // Clear previous content
        
        if (!items || items.length === 0) return false;
        
        items.forEach(item => {
          if (!item.imageUrl) return;
          
          const div = document.createElement('div');
          div.className = 'accordion-item';
          const content = document.createElement('div');
          content.className = 'accordion-content';
          
          // Create the profile container
          const profileContainer = document.createElement('div');
          profileContainer.className = 'user-profile-container';
          
          // Regular goat image with caching
          const img = createCachedImage(
            item.imageUrl, 
            item.name, 
            item.name
          );
          profileContainer.appendChild(img);
          
          // Add text container for name
          const textContainer = document.createElement('div');
          textContainer.className = 'user-profile-text';
          
          // Add name
          const nameElement = document.createElement('span');
          nameElement.className = 'user-profile-name';
          nameElement.innerText = item.name || "Goat";
          textContainer.appendChild(nameElement);
          
          profileContainer.appendChild(textContainer);
          content.appendChild(profileContainer);
          
          div.appendChild(content);
          accordionContainer.appendChild(div);
          gsap.to(content, { opacity: 1, duration: animationConfig.accordion.transitionDuration / 1000 });
        });
        
        // Use the shared function to show the accordion
        showAccordionContainer();
        
        return true;
      }
      
      function toggleQRCodeImage() {
        gsap.to(qrCodeImg, {
          duration: animationConfig.qrCode.flashDuration / 1000,
          opacity: 0,
          onComplete: () => {
            qrCodeImg.style.display = 'none';
            lightningImg.style.display = 'block';
            gsap.to(lightningImg, { 
              duration: animationConfig.qrCode.flashDuration / 1000, 
              opacity: 1 
            });
          }
        });
        setTimeout(() => {
          gsap.to(lightningImg, {
            duration: 0.5,
            opacity: 0,
            onComplete: () => {
              lightningImg.style.display = 'none';
              qrCodeImg.style.display = 'block';
              gsap.to(qrCodeImg, { duration: 0.5, opacity: 1 });
            }
          });
        }, animationConfig.qrCode.displayDuration);
      }
      
      function updateCurrentTime() {
        const now = new Date();
        currentTimeElem.innerText = formatTime(now);
      }
      
      async function fetchTemperature() {
        try {
          const data = await fetchData(`${API_BASE_URL}/get_received_data`);
          const temp = data.AmbientWeatherWS2902A_WeatherDataWs2902a_Temperature;
          if (temp !== undefined) {
            const temperature = Math.round(temp);
            currentTempElem.innerText = `${temperature} °F`;
          }
        } catch (error) {}
      }
      
      function triggerLightningEffect() {
        const lightningEffect = document.getElementById('lightning-effect');
        lightningEffect.style.display = 'block';
        
        let flashCount = 0;
        const flash = () => {
          if (flashCount >= animationConfig.lightning.flashCount) {
            lightningEffect.style.display = 'none';
            return;
          }
          
          gsap.to(lightningEffect, {
            opacity: 1,
            duration: animationConfig.lightning.flashDuration / 2000,
            onComplete: () => {
              gsap.to(lightningEffect, {
                opacity: 0,
                duration: animationConfig.lightning.flashDuration / 2000,
                onComplete: () => {
                  flashCount++;
                  flash();
                }
              });
            }
          });
        };
        flash();
      }
      
      function triggerFeederEffect() {
        feederTriggeredText.style.display = 'block';
        gsap.fromTo(feederTriggeredText,
          { opacity: 0, scale: animationConfig.feeder.scalingStart },
          { opacity: 1, scale: 1, duration: 0.5, ease: 'back.out(1.7)' });
        gsap.to(feederTriggeredText, {
          opacity: 0,
          scale: animationConfig.feeder.scalingEnd,
          duration: 0.5,
          delay: animationConfig.feeder.effectDuration / 1000,
          ease: 'back.in(1.7)',
          onComplete: () => {
            feederTriggeredText.style.display = 'none';
            isAnimating = false;
          }
        });
      }
      
      document.addEventListener('DOMContentLoaded', async function () {
        try {
          // Initialize image cache first
          await imageCache.initCache();
          
          // Start preloading images in background
          imageCache.preloadImages(getPreloadImageUrls());
          
          // Set initial/fallback values for display elements
          updateCurrentTime(); // Set initial time
          satsLeftElem.innerText = `⚡Loading...⚡`;
          goatFeedingsElem.innerText = `The ⚡Lightning Goats⚡ have been fed today.`;
          currentTempElem.innerText = `-- °F`;
          spotsRemainingElem.innerText = `CyberHerd spots left: --`;
          progressText.innerText = `0%`;
          
          // Initialize WebSockets first for faster real-time data
          initWebSocket();
          initWebSocketFastAPI();
          
          // Fetch initial data in parallel
          const fetchPromises = [
            fetchGoal(),
            fetchBalance(),
            fetchFeedings(),
            fetchSpotsRemaining(),
            fetchTemperature()
          ];
          
          // Wait for all fetches to complete but proceed even if some fail
          await Promise.allSettled(fetchPromises);
          
          // Update the display with fetched data
          updateSatsLeft();
          updateProgressBar();
          
          // Set up recurring updates
          setInterval(fetchTemperature, FETCH_INTERVAL);
          setInterval(updateCurrentTime, 1000);
          
          // Set up cache cleaning - once a week
          setTimeout(() => {
            imageCache.cleanCache(7);
          }, 60000); // Clean cache after 1 minute of page load
          
        } catch (error) {
          console.error("Error during initialization:", error);
          // Still try to display something useful
          updateCurrentTime();
          satsLeftElem.innerText = `⚡Connect to see sats progress⚡`;
        }
      });

      // Add the CSS style for message separator
      const styleSheet = document.createElement("style");
      styleSheet.textContent = `
        #scrolling-comment .message-separator {
          color: #e33502;
          font-weight: bold;
          margin: 0 10px;
          display: inline-block;
        }
      `;
      document.head.appendChild(styleSheet);
      
      // Helper function to format kinds for display
      function formatKinds(kinds) {
        if (!kinds) return "";
        
        // If kinds is a string (comma-separated list), convert to array
        let kindsArray = kinds;
        if (typeof kinds === 'string') {
          kindsArray = kinds.split(',').map(k => k.trim()).filter(k => k);
        }
        
        // Convert kinds to readable labels with icons
        const kindLabels = {
          '6': '↻ Repost',     // Unicode circular arrow
          '7': '❤️ Reaction',   // Unicode heart
          '9734': '⚡ Zap'      // Unicode lightning bolt
        };
        
        // Format each kind with its label if available
        return Array.from(new Set(kindsArray)).map(kind => {
          const kindNum = String(kind).trim();
          return kindLabels[kindNum] || `Kind ${kindNum}`;
        }).join(' • ');
      }
      
      // Display CyberHerd members
      function displayCyberHerdMembers(members, newestPubkey = null) {
        if (!members || !Array.isArray(members) || members.length === 0) return false;
        
        // Get the accordion container
        const accordionContainer = document.getElementById('accordion-container');
        accordionContainer.innerHTML = ""; // Clear existing content
        
        // Sort members by timestamp if available, or keep original order
        const sortedMembers = members.sort((a, b) => {
          // If timestamps are available, use them
          if (a.timestamp && b.timestamp) return b.timestamp - a.timestamp;
          // Otherwise use current positions in the array
          return 0;
        });
        
        // Limit to MAX_DISPLAYED_MEMBERS
        const displayMembers = sortedMembers.slice(0, MAX_DISPLAYED_MEMBERS);
        
        // Create the accordion items for each member
        displayMembers.forEach(member => {
          // Extract all needed properties with fallbacks
          const pubkey = member.pubkey || "";
          const imageUrl = member.picture || member.imageUrl || "";
          const name = member.display_name || member.name || "Anon";
          const kinds = member.kinds || "";
          const amount = member.amount || 0;
          const isNewest = newestPubkey ? pubkey === newestPubkey : member.is_newest;
          
          // Skip if no image URL (shouldn't happen but just in case)
          if (!imageUrl) return;
          
          // Create the accordion item element
          const div = document.createElement('div');
          div.className = 'accordion-item user-profile';
          
          // Create the content container
          const content = document.createElement('div');
          content.className = 'accordion-content user-profile';
          
          // Create the image with proper caching
          const img = createCachedImage(
            imageUrl,
            name,
            name,
            { fallback: "images/lightninggoatslogo1.png" }
          );
          
          // Create the profile container
          const profileContainer = document.createElement('div');
          profileContainer.className = 'user-profile-container';
          profileContainer.appendChild(img);
          
          // Add text container for name and kinds
          const textContainer = document.createElement('div');
          textContainer.className = 'user-profile-text';
          
          // Add name
          const nameElement = document.createElement('span');
          nameElement.className = 'user-profile-name';
          nameElement.innerText = name;
          textContainer.appendChild(nameElement);
          
          // Add kinds if available
          if (kinds) {
            const kindsElement = document.createElement('span');
            kindsElement.className = 'user-profile-kinds';
            kindsElement.innerText = formatKinds(kinds); 
            textContainer.appendChild(kindsElement);
          }
          
          // Add zap amount if available
          if (amount > 0) {
            const zapElement = document.createElement('span');
            zapElement.className = 'user-profile-zap';
            zapElement.innerText = `⚡ ${amount} sats`;
            textContainer.appendChild(zapElement);
          }
          
          profileContainer.appendChild(textContainer);
          content.appendChild(profileContainer);
          
          // Highlight newest member with a subtle effect
          if (isNewest) {
            content.style.border = "2px solid #ffdb58";
            // Add a data attribute for potential additional styling
            div.dataset.newest = "true";
          }
          
          div.appendChild(content);
          accordionContainer.appendChild(div);
          gsap.to(content, { opacity: 1, duration: animationConfig.accordion.transitionDuration / 1000 });
        });
        
        // Show the accordion container
        showAccordionContainer();
        
        return true;
      }
      
      // Add missing function to show accordion container
      function showAccordionContainer() {
        const accordionContainer = document.getElementById('accordion-container');
        
        // Clear any existing timeout that might hide the accordion
        if (accordionTimeout) {
          clearTimeout(accordionTimeout);
          accordionTimeout = null;
        }
        
        // Show and animate the accordion container
        accordionContainer.style.display = 'flex';
        gsap.to(accordionContainer, {
          opacity: 1,
          x: 0, // Animate from left (x) instead of top (y)
          duration: animationConfig.accordion.transitionDuration / 1000
        });
        
        // Set a timeout to hide the accordion after the display duration
        accordionTimeout = setTimeout(() => {
          gsap.to(accordionContainer, {
            opacity: 0,
            x: -100, // Move back to left when hiding
            duration: animationConfig.accordion.transitionDuration / 1000,
            onComplete: () => {
              accordionContainer.style.display = 'none';
            }
          });
        }, animationConfig.accordion.displayDuration);
      }
    })();
  </script>
</body>
</html>
