<!DOCTYPE html>
<html>

<head>
    <title>js overlay</title>
    <meta charset="UTF-8">
    <link rel="icon" href="data:," type="image/x-icon">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.10.4/gsap.min.js"></script>
    <style>
        /* Existing CSS */
        #container {
            position: absolute;
            width: 1280px;
            height: 720px;
            margin: auto;
            top: 0;
            left: 0;
        }

        #qr-code {
            position: absolute;
            top: 2px;
            right: 5px;
            background-color: white;
            width: 120px;
            height: 120px;
            border-top-left-radius: 12px;
            border-top-right-radius: 12px;
            z-index: 3;
        }

        #sats_left {
            position: absolute;
            top: 121px;
            right: 5px;
            width: 120px;
            padding-bottom: 3px;
            text-align: center;
            font-size: 12px;
            font-weight: bold;
            font-family: 'Arial', sans-serif;
            background-color: white;
            border-bottom-left-radius: 12px;
            border-bottom-right-radius: 12px;
            z-index: 3;
        }

        #content {
            width: 100%;
            display: flex;
            justify-content: center;
            align-items: center;
            flex-direction: column;
        }

        #bottom-container {
            display: flex;
            align-items: center;
            background-color: #e33502;
            border-radius: 12px;
	    padding: 3px 6px;
            position: absolute;
            bottom: 0;
            left: 0;
            width: 100%;
            box-sizing: border-box;
            z-index: 0;
        }

        #time-temperature-container {
            flex-shrink: 0;
            display: flex;
            align-items: center;
            background-color: #e33502;
            border-radius: 7px;
            padding: 3px 6px;
            font-size: 12px;
            font-weight: bold;
            font-family: 'Arial', sans-serif;
            color: white;
            z-index: 2;
        }

        #current-time,
        #current-temperature {
            margin-right: 5px;
        }

        #center-container {
            flex-grow: 1;
            display: flex;
            justify-content: center;
            position: relative;
        }

        #progress-container {
            width: 99%;
            height: 13px;
            background-color: #e6e6e6;
            border-radius: 7px;
            position: relative;
            z-index: 2;
            overflow: hidden;
        }

        #progress-fill {
            height: 100%;
            background-color: #e6b800;
            border-radius: 7px;
            width: 0%;
        }

        #progress-text {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            text-align: center;
            font-size: 10px;
            font-family: 'Arial', sans-serif;
            font-weight: bold;
            line-height: 13px;
            color: #000;
            z-index: 3;
            white-space: nowrap;
            overflow: visible;
        }

        /* Scrolling text animation */
        .scrolling {
            animation: scroll-text linear infinite;
        }

        @keyframes scroll-text {
            0% {
                transform: translateX(100%);
            }

            100% {
                transform: translateX(-100%);
            }
        }

        /* New CSS for Horizontal Accordion */
        #accordion-container {
            position: absolute;
            top: 3px;
            left: 3px;
            bottom: 3px;
            height: 120px;
            background-color: transparent;
            display: flex;
            overflow: hidden;
            z-index: 10;
            opacity: 0;
            transform: translateX(-100%);
        }

        .accordion-item {
            background-color: #e33502;
            width: 120px;
            height: 120px;
            position: relative;
        }

        .accordion-content {
            background-color: #e33502;
            height: 100%;
            display: flex;
            flex-direction: column;
            justify-content: flex-end;
            opacity: 0;
        }

        .accordion-content img {
            height: 110px;
            width: 110px;
            display: block;
            margin: auto;
        }

        /* New CSS for Lightning Effect */
        #lightning-effect {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: white;
            opacity: 0;
            z-index: 6;
            display: none;
        }

        /* CSS for Goal Achieved Layer */
        #goal-achieved-layer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(230, 184, 0, 0.5); /* #e6b800 with transparency */
            z-index: 5; /* Just below the lightning effect */
            opacity: 0;
            display: none;
            text-align: center;
            font-size: 48px;
            font-weight: bold;
            color: white;
            line-height: 720px; /* Vertically center the text */
        }

#feeder-triggered {
    position: absolute;
    width: 100%;
    height: 100%;
    top: 0;
    left: 0;
    text-align: center;
    color: black; /* Change initial color to black */
    font-size: 48px;
    font-weight: bold;
    display: none;
    z-index: 7;
    line-height: 720px;
}

    </style>
</head>

<body>
    <div id="container">
        <div id="goal-achieved-layer"></div>
        <div id="feeder-triggered">Feeder Triggered!</div>
        <div id="qr-code">
            <img src="images/qr.png" width='120' height='120' style="border-radius: 12px;">
            <img id="lightning-img" src="images/lightning.png" width='117' height='117' style="border-radius: 12px; display: none;">
        </div>
        <div id="sats_left"></div>
        <div id="content">
            <div id="bottom-container">
                <div id="time-temperature-container">
                    <div id="current-time"></div>
                    <div id="current-temperature"></div>
                </div>
                <div id="center-container">
                    <div id="progress-container">
                        <div id="progress-fill"></div>
                        <div id="progress-text"></div>
                    </div>
                </div>
            </div>
        </div>
        <!-- Accordion Container -->
        <div id="accordion-container" style="display: none;"></div>
        <!-- Lightning Effect Overlay -->
        <div id="lightning-effect"></div>
    </div>

    <script>
        let balance = 0;
        let goal = 0;
        let lastSuccessfulGoal = 0;
        let lastSuccessfulBalance = 0;
        let goalAchieved = false;
        let isAnimating = false;
        let messageQueue = [];
        let isScrolling = false;
        let accordionTimeout = null;
        const reconnectInterval = 30000;

        // Goat information
        const goats = {
            "Newton": { img: "images/newton.png" },
            "Nova": { img: "images/nova.png" },
            "Cosmo": { img: "images/cosmo.png" },
            "Dexter": { img: "images/dexter.png" },
            "Rowan": { img: "images/rowan.png" }
        };

        function fetchConversionRate() {
            var xhr = new XMLHttpRequest();
            xhr.open('GET', 'https://lightning-goats.com/convert/0.01', true);
            xhr.onreadystatechange = function () {
                if (xhr.readyState == 4) {
                    if (xhr.status == 200) {
                        // Handle the conversion rate if needed
                    } else {
                        console.error('Error fetching conversion rate:', xhr.statusText);
                    }
                }
            };
            xhr.send();
        }

        function fetchAndDisplayMessages(info = false) {
            let url = "https://lightning-goats.com/messages";
            if (info === true) {
                url += "/info";
            }

            var xhr = new XMLHttpRequest();
            xhr.open('GET', url, true);
            xhr.onreadystatechange = function () {
                if (xhr.readyState == 4) {
                    if (xhr.status == 200) {
                        try {
                            var data = JSON.parse(xhr.responseText);
                            if (Array.isArray(data)) {
                                data.forEach(message => {
                                    let processedMessage = message.content
                                        .replace(/[\r\n]+/g, ' ')
                                        .replace(/\s+/g, ' ')
                                        .replace(/https?:\/\/\S+/g, '') // Remove URLs
                                        .trim();
                                    addMessageToQueue(processedMessage);
                                });
                                resetAllMessages(); // Reset messages after adding to queue
                            } else {
                                console.log("Unexpected data format received:", data);
                            }
                        } catch (e) {
                            console.error('Error parsing messages data:', e);
                        }
                    } else {
                        console.error('Error fetching messages:', xhr.statusText);
                    }
                }
            };
            xhr.send();
        }

        function resetAllMessages() {
            var xhr = new XMLHttpRequest();
            xhr.open('GET', 'https://lightning-goats.com/messages/reset', true);
            xhr.onreadystatechange = function () {
                if (xhr.readyState == 4) {
                    if (xhr.status == 200) {
                        // Messages reset successfully
                    } else {
                        console.error('Error resetting messages:', xhr.statusText);
                    }
                }
            };
            xhr.send();
        }

        function periodicallyUpdate() {
            if (Math.random() < 0.04) {
                fetchAndDisplayMessages(true); // Display informational message
            }

            fetchTemperature();
        }

        function debounce(func, wait) {
            let timeout;
            return function (...args) {
                const later = () => {
                    clearTimeout(timeout);
                    func(...args);
                };
                clearTimeout(timeout);
                timeout = setTimeout(later, wait);
            };
        }

        const debouncedCheckFeederStatus = debounce(checkFeederStatus, 1000);

        function checkFeederStatus() {
            return new Promise((resolve, reject) => {
                var xhr = new XMLHttpRequest();
                xhr.open('GET', 'https://lightning-goats.com/feeder_status', true);
                xhr.onreadystatechange = function () {
                    if (xhr.readyState == 4) {
                        if (xhr.status == 200) {
                            const isFeederOn = xhr.responseText.trim() === 'true';
                            const satsLeftElem = document.getElementById('sats_left');
                            if (isFeederOn) {
                                satsLeftElem.innerText = "Feeder paused";
                            }
                            resolve(isFeederOn);
                        } else {
                            console.error('Failed to fetch feeder status:', xhr.statusText);
                            document.getElementById('sats_left').innerText = "Status error! Check connection.";
                            resolve(false);
                        }
                    }
                };
                xhr.send();
            });
        }

        function initWebSocket() {
            const ws = new WebSocket('wss://lnb.bolverker.com/api/v1/ws/036ad4bb0dcb4b8c952230ab7b47ea52');

            ws.onopen = function () {
                console.log("WebSocket connection opened.");
            };

            ws.onerror = function (error) {
                console.log("WebSocket connection error: ", error);
                setTimeout(initWebSocket, reconnectInterval);
            };

            ws.onmessage = function (event) {
		console.log("Payment received event: ", event.data);
		const data = JSON.parse(event.data);

		const receivedAmount = data.payment.amount / 1000; // Convert from millisatoshis to satoshis
		const commentArray = data.payment.extra && data.payment.extra.comment; // Check if comment array exists
		const comment = commentArray && commentArray.length > 0 ? commentArray[0] : ''; // Extract first comment if available

		// Fetch the latest balance and goal from the server
		Promise.all([fetchGoal(), fetchBalance()])
		    .then(() => {
			checkFeederStatus().then(isFeederOn => {
			    if (!isFeederOn) {
				const currentSatsLeft = goal - balance;
		
				fetchAndDisplayMessages();

				// If the received amount is 100 or more Satoshis and a comment is present
				if (receivedAmount >= goal && comment.trim() !== '') {
				    addMessageToQueue(comment); // Add the comment to the message queue                                                                     
				}

				if (receivedAmount > 0) {
				    updateSatsLeftElem(receivedAmount, currentSatsLeft, true);
				    toggleQRCodeImage();
				    updateProgressBar();

				    setTimeout(() => {
					updateSatsLeftElem(receivedAmount, currentSatsLeft, false);
					updateProgressBar();
				    }, 2000);
				}
			    }
			});
		    })
		    .catch(error => {
			console.error('Error fetching balance or goal:', error);
		    });
	    };

            ws.onclose = function () {
                console.log("WebSocket connection closed. Reconnecting...");
                setTimeout(initWebSocket, reconnectInterval);
            };
        }

        document.addEventListener('DOMContentLoaded', function () {
            Promise.all([fetchGoal(), fetchBalance()])
                .then(() => {
                    updateProgressBar();
                    updateSatsLeftText();
                })
                .catch(error => {
                    console.log("An error occurred:", error);
                });

            initWebSocket();  // Initialize the WebSocket connection
            const updateInterval = 10000;
            setInterval(periodicallyUpdate, updateInterval);
            setInterval(updateCurrentTime, 1000); // Call updateCurrentTime directly to update every second
            setInterval(debouncedCheckFeederStatus, 1000);
            fetchTemperature();
            setInterval(fetchTemperature, updateInterval);
            fetchAndDisplayMessages(); // Fetch messages initially
        });

        function fetchGoal() {
            return new Promise((resolve, reject) => {
                var xhr = new XMLHttpRequest();
                xhr.open('GET', "https://lightning-goats.com/trigger_amount", true);
                xhr.onreadystatechange = function () {
                    if (xhr.readyState == 4) {
                        if (xhr.status == 200) {
                            try {
                                var data = JSON.parse(xhr.responseText);
                                const newGoal = parseFloat(data.trigger_amount);
                                if (!isNaN(newGoal)) {
                                    lastSuccessfulGoal = newGoal;
                                    goal = newGoal;
                                    updateSatsLeftText(); // Update sats left text
                                    resolve();
                                } else {
                                    console.error("Invalid trigger amount received");
                                    goal = lastSuccessfulGoal;
                                    reject(new Error("Invalid trigger amount received"));
                                }
                            } catch (e) {
                                console.error('Error parsing goal data:', e);
                                reject(new Error("Failed to parse goal data"));
                            }
                        } else {
                            console.error('Error fetching goal:', xhr.statusText);
                            goal = lastSuccessfulGoal;
                            reject(new Error("Failed to fetch trigger amount"));
                        }
                    }
                };
                xhr.send();
            });
        }

        function fetchBalance() {
            return new Promise((resolve, reject) => {
                var xhr = new XMLHttpRequest();
                xhr.open('GET', "https://lightning-goats.com/balance", true);
                xhr.onreadystatechange = function () {
                    if (xhr.readyState == 4) {
                        if (xhr.status == 200) {
                            try {
                                var data = JSON.parse(xhr.responseText);
                                if (data && typeof data.balance === 'number' && data.balance >= 0) {
                                    lastSuccessfulBalance = data.balance; // Update last successful balance
                                    balance = Math.round(data.balance);
                                    updateSatsLeftText(); // Update sats left text
                                    resolve();
                                } else {
                                    console.error("Invalid balance data received:", data);
                                    balance = lastSuccessfulBalance || 0; // Fallback to last known balance
                                    reject(new Error("Invalid balance data received"));
                                }
                            } catch (e) {
                                console.error('Error parsing balance data:', e);
                                balance = lastSuccessfulBalance || 0; // Fallback to last known balance
                                reject(new Error("Failed to parse balance data"));
                            }
                        } else {
                            console.error("Error fetching balance:", xhr.statusText);
                            balance = lastSuccessfulBalance || 0; // Fallback to last known balance
                            reject(new Error("Failed to fetch balance"));
                        }
                    }
                };
                xhr.send();
            });
        }

        function updateSatsLeftElem(receivedAmount, currentSatsLeft, toggle) {
            const satsLeftElem = document.getElementById('sats_left');
            if (toggle) {
                satsLeftElem.innerText = `${Math.round(receivedAmount)} sats received`;
            } else {
                // Update remaining sats based on the current balance and goal
                Promise.all([fetchGoal(), fetchBalance()]).then(() => {
                    const newSatsLeft = Math.max(goal - balance, 0); // Ensure non-negative value
                    if (newSatsLeft > 0) {
                        satsLeftElem.innerText = `${Math.round(newSatsLeft)} sats to go`;
                    } else {
                        satsLeftElem.innerText = `Goal reached!`;
                    }
                    updateProgressBar(); // Ensure the progress bar is also updated
                }).catch((error) => {
                    console.error('Error fetching goal or balance:', error);
                });
            }
        }

        function updateSatsLeftText() {
            let satsLeft = Math.round(Math.max(goal - balance, 0));
            document.getElementById('sats_left').innerText = `${satsLeft} sats to go`;
        }

        function updateProgressBar() {
            if (goal === 0) {
                return;
            }

            const progress = Math.min(Math.max((balance / goal) * 100, 0), 100);
            gsap.to("#progress-fill", { width: `${progress}%`, duration: 2 });
            if (!isScrolling) {
                document.getElementById('progress-text').innerText = `${Math.round(progress)}%`;
            }

            if (progress >= 100 && !goalAchieved && !isAnimating) {
                goalAchieved = true;
                isAnimating = true;
                triggerLightningEffect(); // Call the lightning effect function here
            } else if (progress < 100) {
                goalAchieved = false;
            }
        }

function triggerLightningEffect() {
    const lightningEffect = document.getElementById('lightning-effect');
    const feederTriggeredText = document.getElementById('feeder-triggered');
    const goalAchievedLayer = document.getElementById('goal-achieved-layer');

    gsap.set(lightningEffect, { display: 'block', opacity: 0 });
    gsap.set(goalAchievedLayer, { display: 'block', opacity: 0 });

    gsap.timeline()
        .to([lightningEffect, goalAchievedLayer, feederTriggeredText], {
            opacity: 1,
            duration: 0.1,
            repeat: 3,
            yoyo: true,
            onStart: () => {
                feederTriggeredText.style.display = 'block';
                goalAchievedLayer.style.display = 'block';
            },
            onRepeat: () => {
                // Invert the text color between black and white
                feederTriggeredText.style.color = feederTriggeredText.style.color === 'white' ? 'black' : 'white';
            }
        })
        .to([feederTriggeredText, goalAchievedLayer], {
            opacity: 1,
            duration: 1, // Set this duration to keep the text visible for 1 second
            onComplete: () => {
                feederTriggeredText.style.display = 'none';
                goalAchievedLayer.style.display = 'none';
            }
        })
        .to(lightningEffect, {
            display: 'none',
            opacity: 0,
            duration: 0,
            onComplete: () => {
                // Fetch the latest balance and goal from the server
                Promise.all([fetchGoal(), fetchBalance()]).then(() => {
                    updateSatsLeftText();
                    updateProgressBar();
                    isAnimating = false; // Reset the animating flag
                }).catch(error => {
                    console.error('Error fetching balance or goal:', error);
                    isAnimating = false; // Ensure flag is reset even on error
                });
            }
        });
}


        function fetchTemperature() {
            var xhr = new XMLHttpRequest();
            xhr.open('GET', 'https://lightning-goats.com/get_received_data', true);
            xhr.onreadystatechange = function () {
                if (xhr.readyState == 4) {
                    if (xhr.status == 200) {
                        try {
                            var data = JSON.parse(xhr.responseText);
                            if (data && data.AmbientWeatherWS2902A_WeatherDataWs2902a_Temperature) {
                                var temperature = Math.round(data.AmbientWeatherWS2902A_WeatherDataWs2902a_Temperature * 10) / 10;
                                document.getElementById('current-temperature').innerText = `${temperature}°F`;
                            } else {
                                console.error('Invalid temperature data received:', data);
                            }
                        } catch (e) {
                            console.error('Error parsing temperature data:', e);
                        }
                    } else {
                        console.error('Error fetching temperature:', xhr.statusText);
                    }
                }
            };
            xhr.send();
        }

        function updateCurrentTime() {
    const now = new Date();
    const formattedTime = now.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' });
    document.getElementById('current-time').innerText = `${formattedTime}`;
}


        function addMessageToQueue(messageText) {
            messageQueue.push(messageText);
            if (!isScrolling) {
                displayNextMessage();
            }
        }

        function displayNextMessage() {
            if (messageQueue.length > 0 && !isScrolling) {
                const messageText = messageQueue.shift();
                addScrollingComment(messageText);
            }
        }

        function addScrollingComment(commentText) {
            if (isScrolling) {
                return;
            }

            isScrolling = true;

            const progressText = document.getElementById('progress-text');

            // Show accordion if goat names are mentioned
            const hasGoatNames = checkForGoatNames(commentText);

            // Prepare the scrolling text
            progressText.innerText = commentText;
            progressText.classList.add('scrolling');

            // Calculate animation duration based on text length
            const textWidth = progressText.scrollWidth;
            const containerWidth = progressText.offsetWidth;
            const totalDistance = textWidth + containerWidth;
            const scrollSpeed = 100; // pixels per second
            const scrollDuration = totalDistance / scrollSpeed;

            progressText.style.animationDuration = `${scrollDuration}s`;

            // When animation ends
            setTimeout(() => {
                progressText.classList.remove('scrolling');
                isScrolling = false;
                updateProgressBar(); // Restore progress percentage

                if (messageQueue.length > 0) {
                    displayNextMessage();
                }

                if (!hasGoatNames && accordionTimeout === null) {
                    gsap.to("#accordion-container", {
                        x: '-100%',
                        opacity: 0,
                        duration: 1,
                        onComplete: () => {
                            gsap.set("#accordion-container", { display: 'none' });
                        }
                    }); // Retract accordion when scrolling ends
                }
            }, scrollDuration * 1000);
        }

        function toggleQRCodeImage() {
            const qrCode = document.querySelector('#qr-code img:first-child');
            const lightningImg = document.getElementById('lightning-img');

            // Hide the QR code and show the lightning image
            gsap.to(qrCode, {
                duration: 0.125, opacity: 0, onComplete: () => {
                    qrCode.style.display = 'none';
                    lightningImg.style.display = 'block';
                    gsap.to(lightningImg, { duration: 0.125, opacity: 1 });
                }
            });

            // Hide the lightning image and show the QR code after 2 seconds
            setTimeout(() => {
                gsap.to(lightningImg, {
                    duration: 0.5, opacity: 0, onComplete: () => {
                        lightningImg.style.display = 'none';
                        qrCode.style.display = 'block';
                        gsap.to(qrCode, { duration: 0.5, opacity: 1 });
                    }
                });
            }, 2000);
        }

        function updateTextWithGSAP(element, newText, duration = 0.5) {
            gsap.to(element, {
                duration: duration / 2,
                opacity: 0,
                onComplete: () => {
                    element.innerText = newText;
                    gsap.to(element, { duration: duration / 2, opacity: 1 });
                }
            });
        }

        function checkForGoatNames(messageText) {
            const goatNames = Object.keys(goats);
            const matchedGoats = [];

            // Extract the order of goat names as they appear in the message
            goatNames.forEach(name => {
                if (messageText.includes(name)) {
                    const index = messageText.indexOf(name);
                    matchedGoats.push({ name, index });
                }
            });

            // Sort the matched goats based on their order in the message
            matchedGoats.sort((a, b) => a.index - b.index);

            const accordionContainer = document.getElementById('accordion-container');
            accordionContainer.innerHTML = ""; // Clear previous content

            if (matchedGoats.length > 0) {
                matchedGoats.forEach(({ name }) => {
                    const goat = goats[name];
                    const item = document.createElement('div');
                    item.className = 'accordion-item';

                    const content = document.createElement('div');
                    content.className = 'accordion-content';

                    const img = document.createElement('img');
                    img.src = goat.img;
                    img.alt = name;

                    content.appendChild(img);
                    item.appendChild(content);

                    accordionContainer.appendChild(item);

                    // Only change opacity of the content
                    gsap.to(content, { opacity: 1, duration: 1 }); // Slower animation
                });

                // GSAP animation for sliding in the accordion container from the left
                gsap.set(accordionContainer, { display: 'flex', x: '-100%' });
                const containerWidth = accordionContainer.scrollWidth;
                gsap.to(accordionContainer, { x: 0, opacity: 1, duration: 1, width: containerWidth });

                // Clear any previous accordion timeout
                if (accordionTimeout !== null) {
                    clearTimeout(accordionTimeout);
                    accordionTimeout = null;
                }

                // Ensure accordion stays visible for a fixed duration
                accordionTimeout = setTimeout(() => {
                    gsap.to(accordionContainer, {
                        x: '-100%',
                        opacity: 0,
                        duration: 1,
                        onComplete: () => {
                            gsap.set("#accordion-container", { display: 'none' });
                        }
                    });
                    accordionTimeout = null;
                }, 18000); // Duration set to 18 seconds
                return true;
            }
            return false;
        }
    </script>
</body>

</html>
