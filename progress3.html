<!DOCTYPE html>
<html>
<head>
  <title>js overlay</title>
  <meta charset="UTF-8">
  <link rel="icon" href="data:," type="image/x-icon">
  <style>
    /* General Styles */
    body {
      margin: 0;
      padding: 0;
      font-family: 'Arial', sans-serif; 
    }
    
    #container {
      position: absolute;
      width: 1920px; 
      height: 1080px; 
      margin: auto;
      top: 0;
      left: 0;
    }
    
    #qr-code {
      position: absolute;
      top: 3px; 
      right: 8px; 
      background-color: white;
      width: 180px; 
      height: 180px; 
      border-radius: 18px; 
      z-index: 3;
      box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
      transition: transform 0.2s ease-out, box-shadow 0.2s ease-out;
    }
    #qr-code:hover {
      transform: scale(1.03);
      box-shadow: 0 6px 18px rgba(0, 0, 0, 0.15);
    }
    
    #sats-received-overlay {
      position: absolute;
      top: 188px; 
      right: 8px;   
      width: 180px; 
      text-align: center; 
      font-size: 18px;
      font-weight: bold;
      font-family: 'Arial', sans-serif;
      color: black;
      background-color: rgba(255, 255, 255, 0.95); 
      padding: 5px 10px;
      border-radius: 8px;
      pointer-events: none;
      z-index: 4; 
      opacity: 0;
      white-space: nowrap;
      box-shadow: 0 2px 5px rgba(0,0,0,0.2);
      box-sizing: border-box; 
    }
    
    #content {
      width: 100%;
      display: flex;
      justify-content: center;
      align-items: center;
      flex-direction: column;
    }
    
    #top-left-container {
      display: flex;
      flex-direction: row; 
      align-items: center;
      background-color: #000000;
      border-radius: 18px;
      padding: 5px 9px;
      position: absolute;
      top: 5px;
      left: 5px;
      box-sizing: border-box;
      z-index: 0;
      box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
    }
    
    #goat-feedings,
    #spots-remaining,
    #sats_left {
      color: white;
      font-weight: bold;
      font-size: 18px;
      font-family: 'Arial', sans-serif;
      margin-right: 10px;
      transition: color 0.5s ease-out; 
    }
    
    #bottom-container {
      display: flex;
      align-items: center;
      background-color: #e33502; 
      background-image: linear-gradient(to bottom, #e33502, #c82a00);
      border-radius: 18px;
      padding: 5px 9px;
      position: absolute;
      bottom: 0;
      left: 0;
      width: 100%;
      box-sizing: border-box;
      z-index: 0;
      box-shadow: 0 -4px 12px rgba(0, 0, 0, 0.15);
    }
    
    #time-temperature-container {
      flex-shrink: 0;
      display: flex;
      align-items: center;
      background-color: #e33502;
      border-radius: 11px;
      padding: 5px 9px;
      font-size: 18px;
      font-weight: bold;
      font-family: 'Arial', sans-serif;
      color: white;
      z-index: 2;
    }
    
    #current-time,
    #current-temperature {
      margin-right: 8px;
    }
    
    #wallet-balance {
      margin-left: 8px;
    }
    
    #center-container {
      flex-grow: 1;
      display: flex;
      justify-content: center;
      position: relative;
    }
    
    #progress-container {
      position: relative;
      width: 99%;
      height: 20px;
      background-color: #d0d0d0; 
      border-radius: 11px;
      overflow: hidden;
      z-index: 2;
      box-shadow: inset 0 1px 3px rgba(0,0,0,0.25); 
    }
    
    #progress-fill {
      height: 100%;
      background-color: #e6b800; 
      background-image: linear-gradient(
        -45deg, 
        rgba(230,184,0,1) 25%,  
        rgba(235,195,20,1) 25%,  
        rgba(235,195,20,1) 50%,
        rgba(230,184,0,1) 50%,
        rgba(230,184,0,1) 75%,
        rgba(235,195,20,1) 75%,
        rgba(235,195,20,1) 100%
      );
      background-size: 20px 20px; 
      border-radius: 11px;
      width: 0%;
      z-index: 1; 
      position: relative; 
    }

    #progress-fill.is-filling { 
        animation: pulseFill 1.5s infinite ease-in-out, progressBarFlow 1.8s linear infinite; 
    }
    @keyframes pulseFill {
        0%, 100% { filter: brightness(100%); }
        50% { filter: brightness(110%); } 
    }
    @keyframes progressBarFlow {
      0% { background-position: 0 0; }
      100% { background-position: 20px 0; } 
    }


    #progress-fill.shine-effect::after { 
        content: '';
        position: absolute;
        top: 0;
        left: -150%; 
        width: 100%; 
        height: 100%;
        background: linear-gradient(90deg, transparent, rgba(255,255,255,0.4), transparent); 
        animation: shine 0.75s forwards;
        border-radius: 11px; 
    }
    @keyframes shine {
        to { left: 150%; } 
    }

    #progress-drainer { 
        position: absolute;
        top: 0;
        right: 0; 
        width: 0%; 
        height: 100%;
        background-color: #d0d0d0; 
        border-radius: 11px;
        z-index: 2; 
        display: none; 
    }
        
    #scrolling-comment {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%; 
      height: 100%;
      z-index: 3; 
      overflow: hidden;
      pointer-events: none;
    }
    
    #scrolling-comment .message {
      position: absolute; 
      white-space: nowrap;
      font-size: 18px;
      font-weight: bold;
      color: #000; 
      will-change: transform;
      background-color: #d0d0d0; 
      padding: 4px 10px; 
      border-radius: 11px;  
    }
    
    #accordion-container {
      position: absolute;
      top: 50px; 
      left: 8px; 
      width: auto; 
      height: auto; 
      background-color: transparent;
      display: flex;
      flex-direction: row;  
      overflow: visible; 
      z-index: 3;
      opacity: 0;
      transform: translateX(-100%); 
    }
    
    .accordion-item {
      background-color: #000000;
      width: 130px; 
      height: 190px; 
      position: relative;
      margin-right: 10px; 
      border-radius: 18px; 
      overflow: hidden; 
      box-shadow: 0 3px 8px rgba(0,0,0,0.2);
      opacity: 0; 
    }
    
    .accordion-item.user-profile {
      height: 190px; 
    }
    
    .accordion-content {
      background-color: #000000;
      height: 100%;
      display: flex;
      flex-direction: column; 
      justify-content: flex-start; 
      opacity: 1; 
      padding: 10px 5px; 
      align-items: center;
      border-radius: 18px; 
      transition: transform 0.2s ease-out, box-shadow 0.2s ease-out; 
    }

    .accordion-item:hover .accordion-content {
        transform: translateY(-3px);
        box-shadow: 0 5px 12px rgba(255, 219, 88, 0.4); 
    }
    
    .accordion-content img {
      height: 100px;
      width: 100px;
      display: block;
      margin-top: 10px; 
      margin-bottom: 8px; 
      border-radius: 50%; 
      object-fit: cover; 
      border: 2px solid white; 
      box-shadow: 0 4px 8px rgba(0,0,0,0.2); 
    }
    
    @keyframes breathe {
      0% { transform: scale(1); }
      50% { transform: scale(1.05); }
      100% { transform: scale(1); }
    }
    
    [data-newest="true"] .accordion-content img {
      animation: breathe 3s infinite ease-in-out;
    }

    .user-profile-container {
      display: flex;
      flex-direction: column; 
      align-items: center;
      justify-content: flex-start; 
      text-align: center; 
      width: 100%;
      padding: 0 5px;
      box-sizing: border-box;
    }
    
    .user-profile-text {
      width: 100%;
      display: flex;
      flex-direction: column;
      justify-content: flex-start; 
      align-items: center;
      margin-top: 5px; 
    }
    
    .user-profile-name {
      color: white;
      font-weight: bold;
      font-size: 12px;
      overflow: hidden;
      text-overflow: ellipsis;
      max-width: 120px;
      white-space: nowrap;
      text-align: center;
    }
    
    .user-profile-kinds {
      color: #ffdb58;
      font-weight: bold;
      font-size: 12px;
      margin-top: 2px;
      overflow: hidden;
      text-overflow: ellipsis;
      max-width: 120px;
      white-space: nowrap;
      display: block; 
      text-align: center;
    }
    
    .user-profile-zap {
      color: #ffdb58;
      font-weight: bold;
      font-size: 12px;
      margin-top: 2px;
      display: block;
      text-align: center;
    }

    #lightning-effect {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background-color: #F0F8FF; 
      z-index: 1000;
      pointer-events: none;
      display: none;
      opacity: 0;
    }

    #feeder-triggered {
        position: absolute;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        color: white; 
        padding: 30px 60px; 
        border-radius: 15px; 
        font-size: 36px; 
        font-weight: bold;
        text-shadow: 0 0 5px rgba(0,0,0,0.7); 
        display: none;
        z-index: 7;
        transition: color 0.05s linear; 
    }

    body.lightning-flash-on #feeder-triggered {
        color: black;
        text-shadow: 0 0 3px rgba(255,255,255,0.5); 
    }

  </style>
  <!-- GSAP Library -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.10.4/gsap.min.js" defer></script>
</head>
<body>
  <div id="container">
    <div id="feeder-triggered" style="display: none;">⚡ Feeder Triggered ⚡</div>
    
    <div id="top-left-container">
      <span id="spots-remaining"></span>
      <span id="sats_left">⚡0 sats to go until the herd is fed again.⚡</span>
    </div>
    
    <div id="qr-code">
      <img src="images/qr.png" width="180" height="180" style="border-radius: 18px;">
      <img id="lightning-img" src="images/lightning.png" width="177" height="177" style="border-radius: 18px; display: none;">
    </div>
    <div id="sats-received-overlay"></div> 
    
    <div id="content">
      <div id="bottom-container">
        <div id="time-temperature-container">
          <div id="current-time">--:--</div>
          <div id="current-temperature">-- °F</div>
        </div>
        <div id="center-container">
          <div id="progress-container">
            <div id="progress-fill"></div>
            <div id="progress-drainer"></div> 
            <div id="scrolling-comment"></div>
          </div>
        </div>
      </div>
    </div>
    <div id="accordion-container" style="display: none;"></div>
    <div id="lightning-effect"></div>
  </div>
  <script>
    (function () {
      const RECONNECT_INTERVAL_BASE = 30000; 
      const MAX_RECONNECT_INTERVAL = 60000; 
      const FETCH_INTERVAL = 16000;
      const SATS_LEFT_DISPLAY_DURATION = 2500; 
      const WS_URL = 'wss://lnb.bolverker.com/api/v1/ws/036ad4bb0dcb4b8c952230ab7b47ea52';
      const WS_URL_FASTAPI = 'wss://lightning-goats.com/ws/';
      const API_BASE_URL = 'https://lightning-goats.com';
      const MAX_PROCESSED_HASHES = 25;
      const MAX_DISPLAYED_MEMBERS = 10; 
      
      const animationConfig = {
        message: {
          scrollSpeed: 200,       
          spacing: 30,            
          separator: " ⚡ ", 
          checkPoints: [0.8, 0.5, 0.3], 
          separatorColor: "#e33502" 
        },
        accordion: {
          displayDuration: 18000, 
          transitionDuration: 1000, 
          itemStagger: 0.1, 
          breatheAnimationDuration: 3000 
        },
        qrCode: {
          flashDuration: 125,    
          displayDuration: 2000  
        },
        satsReceivedOverlay: {
          entryDuration: 0.4, 
          exitDuration: 0.3, 
        },
        feeder: {
          effectDuration: 2000,  
          scalingStart: 0.8,     
          scalingEnd: 1.2        
        },
        lightning: {
          flashDuration: 150,    
          flashCount: 3          
        },
        progressBar: {
          updateDuration: 2000,   
          shineDuration: 750,
          popDuration: 300, 
          colorFlashDuration: 200, 
          drainDuration: 800 
        },
        dataUpdate: {
            highlightColor: "#ffdb58", 
            originalColorText: "white", 
            duration: 0.8 
        }
      };
      
      const container = document.getElementById('container');
      const feederTriggeredText = document.getElementById('feeder-triggered');
      const qrCode = document.getElementById('qr-code');
      const qrCodeImg = document.querySelector('#qr-code img:first-child');
      const lightningImg = document.getElementById('lightning-img');
      const satsLeftElem = document.getElementById('sats_left');
      const currentTimeElem = document.getElementById('current-time');
      const currentTempElem = document.getElementById('current-temperature');
      const spotsRemainingElem = document.getElementById('spots-remaining');
      const progressContainer = document.getElementById('progress-container'); 
      const progressFill = document.getElementById('progress-fill');
      const progressDrainer = document.getElementById('progress-drainer'); 
      const scrollingComment = document.getElementById('scrolling-comment');
      const satsReceivedOverlay = document.getElementById('sats-received-overlay');
      
      let balance = 0; 
      let goal = 0;
      let lastSuccessfulGoal = 0;
      let lastSuccessfulBalance = 0;
      // let isAnimating = false; // Replaced by isFeederAnimating
      let isFeederAnimating = false; // New flag
      
      let messageQueue = [];
      let activeMessages = []; 
      let messageSpacing = animationConfig.message.spacing; 
      let messageCheckInterval = null;
      const MESSAGE_SEPARATOR = animationConfig.message.separator; 
      
      let cyberHerdMembers = [];
      
      let reconnectInterval = RECONNECT_INTERVAL_BASE;
      let processedPaymentHashes = new Set();
      
      const goats = {
        "Newton": { img: "images/newton.png" },
        "Nova": { img: "images/nova.png" },
        "Cosmo": { img: "images/cosmo.png" },
        "Dexter": { img: "images/dexter.png" },
        "Rowan": { img: "images/rowan.png" }
      };
      
      let accordionTimeout = null;
      
      function debounce(func, wait) {
        let timeout;
        return function (...args) {
          clearTimeout(timeout);
          timeout = setTimeout(() => func.apply(this, args), wait);
        };
      }
      
      function throttle(func, limit) {
        let inThrottle;
        return function (...args) {
          if (!inThrottle) {
            func.apply(this, args);
            inThrottle = true;
            setTimeout(() => inThrottle = false, limit);
          }
        };
      }

      function animateTextUpdate(element, newText, highlightColor, originalColor, duration) {
          if (element.innerText !== newText) {
              element.innerText = newText;
              gsap.fromTo(element, 
                  { color: highlightColor }, 
                  { color: originalColor, duration: duration, ease: "power1.inOut" }
              );
          }
      }
      
      function formatTime(date) {
        return date.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' });
      }
      
      const debouncedUpdateProgressBar = debounce(updateProgressBar, 100);
      const throttledUpdateSatsLeft = throttle(updateSatsLeftDisplay, 200); 
      
      async function fetchData(url, options = {}) {
        try {
          const response = await fetch(url, options);
          if (!response.ok) {
            throw new Error(`Error fetching ${url}: ${response.statusText}`);
          }
          const contentType = response.headers.get('content-type');
          if (contentType && contentType.includes('application/json')) {
            return await response.json();
          }
          return await response.text();
        } catch (error) {
          throw error;
        }
      }
      
      async function fetchGoal() {
        if (goal <= 0) {
          try {
            const data = await fetchData(`${API_BASE_URL}/payments/trigger_amount`);
            const newGoal = parseFloat(data.trigger_amount);
            if (!isNaN(newGoal)) {
              lastSuccessfulGoal = newGoal;
              goal = newGoal;
            } else {
              throw new Error("Invalid trigger amount received");
            }
          } catch (error) {
            goal = lastSuccessfulGoal;
          }
        }
      }
      
      async function fetchBalance() {
        if (balance <= 0) {
          try {
            const data = await fetchData(`${API_BASE_URL}/payments/balance`);
            if (data && typeof data.balance === 'number' && data.balance >= 0) {
              const balanceInSats = Math.round(data.balance / 1000);
              lastSuccessfulBalance = balanceInSats;
              balance = balanceInSats;
            } else {
              balance = lastSuccessfulBalance || 0;
              throw new Error("Invalid balance data received");
            }
          } catch (error) {
            balance = lastSuccessfulBalance || 0;
          }
        }
        updateSatsLeftDisplay(); 
      }
      
      async function fetchSpotsRemaining() {
        try {
          const data = await fetchData(`${API_BASE_URL}/cyberherd/spots_remaining`);
          if (data && typeof data.spots_remaining === 'number') {
            const spots = data.spots_remaining;
            animateTextUpdate(spotsRemainingElem, 
                              `CyberHerd spots left: ${spots}`,
                              animationConfig.dataUpdate.highlightColor,
                              animationConfig.dataUpdate.originalColorText,
                              animationConfig.dataUpdate.duration);
          } else {
            spotsRemainingElem.innerText = '';
          }
        } catch (error) {
          spotsRemainingElem.innerText = '';
        }
      }
      
      function addMessageToQueue(text, displayData = null) {
        if (!text) return;
        const cleanedText = text.replace(/https?:\/\/[^\s]+/g, '').replace(/www\.[^\s]+/g, '').trim();
        if (!cleanedText) return;
        messageQueue.push({ text: cleanedText, displayData: displayData });
        tryDisplayMessage();
        if (messageCheckInterval === null) {
            messageCheckInterval = setInterval(tryDisplayMessage, 200);
        }
      }
      
      function tryDisplayMessage() {
        if (messageQueue.length === 0) {
          if (messageCheckInterval !== null && activeMessages.length === 0) {
            clearInterval(messageCheckInterval);
            messageCheckInterval = null;
          }
          return;
        }
        if (activeMessages.length === 0) {
          processNextMessage();
          return;
        }
        const progressBarTotalWidth = progressContainer.offsetWidth; 
        let newestMessage = activeMessages[activeMessages.length - 1];
        let newestMessageRightEdge = newestMessage.x + newestMessage.width;
        const enteredEnough = newestMessageRightEdge <= progressBarTotalWidth - messageSpacing;
        if (enteredEnough) {
          processNextMessage();
        }
      }
      
      function processNextMessage() {
        if (messageQueue.length === 0) return;
        if (isFeederAnimating) { // Don't start new messages if feeder sequence is active
            return; 
        }

        const messageItem = messageQueue.shift();
        const messageText = messageItem.text;
        const displayData = messageItem.displayData;
        if (displayData) {
          displayAccordion(Array.isArray(displayData) ? displayData : [displayData]);
        }
        
        const progressBarTotalWidth = progressContainer.offsetWidth; 
        const messageSpan = document.createElement('span');
        messageSpan.className = 'message';
        const finalMessageText = activeMessages.length > 0 ? 
          MESSAGE_SEPARATOR + messageText : 
          messageText;
        messageSpan.innerText = finalMessageText;
        
        gsap.set(messageSpan, { x: progressBarTotalWidth, top: '50%', y: '-50%' });
        scrollingComment.appendChild(messageSpan);

        requestAnimationFrame(() => {
          const messageWidth = messageSpan.offsetWidth;
          const totalDistance = progressBarTotalWidth + messageWidth; 
          const duration = totalDistance / animationConfig.message.scrollSpeed;
          
          const messageTracker = {
            element: messageSpan,
            width: messageWidth,
            x: progressBarTotalWidth,
            get rightEdge() { return this.x + this.width; },
            initialTimestamp: Date.now()
          };
          activeMessages.push(messageTracker);

          gsap.to(messageSpan, {
            x: -messageWidth,
            duration: duration,
            ease: "linear",
            onUpdate: function() {
              if (isFeederAnimating) return; // Message doesn't control fill during feeder animation

              messageTracker.x = parseFloat(messageSpan._gsap.x); 
              
              const naturalProgressPercent = (goal > 0) ? Math.min(Math.max((balance / goal) * 100, 0), 100) : 0;
              const naturalFillWidthPx = (naturalProgressPercent / 100) * progressBarTotalWidth;

              let newFillWidthPx;

              if (messageTracker.x < naturalFillWidthPx) {
                newFillWidthPx = Math.max(0, messageTracker.x);
              } else {
                newFillWidthPx = naturalFillWidthPx;
              }
              
              newFillWidthPx = Math.min(newFillWidthPx, progressBarTotalWidth);

              gsap.to(progressFill, { width: newFillWidthPx + 'px', duration: 0.05, ease: 'none' });

              const shouldBeFilling = newFillWidthPx > 0 && newFillWidthPx < progressBarTotalWidth;
              if (shouldBeFilling) {
                if (!progressFill.classList.contains('is-filling')) {
                    progressFill.classList.add('is-filling');
                }
              } else {
                if (progressFill.classList.contains('is-filling')) {
                    progressFill.classList.remove('is-filling');
                }
              }
            },
            onComplete: () => {
              const index = activeMessages.findIndex(m => m.element === messageSpan);
              if (index !== -1) activeMessages.splice(index, 1);
              
              if (scrollingComment.contains(messageSpan)) {
                scrollingComment.removeChild(messageSpan);
              }
              
              if (!isFeederAnimating && activeMessages.length === 0) {
                updateProgressBar(); 
              }
              tryDisplayMessage(); 
            }
          });
        });
      }
      
      function updateSatsLeftDisplay(receivedAmount = 0, isNewPayment = false) {
        if (isNewPayment && receivedAmount > 0) {
          displayReceivedAmount(receivedAmount); 
        } else {
          const currentGoal = typeof goal === 'number' ? goal : 0;
          const currentBalance = typeof balance === 'number' ? balance : 0;
          const satsLeft = Math.max(currentGoal - currentBalance, 0);
          animateTextUpdate(satsLeftElem, 
                            `⚡${satsLeft} sats to go until the herd is fed again.⚡`,
                            animationConfig.dataUpdate.highlightColor,
                            animationConfig.dataUpdate.originalColorText,
                            animationConfig.dataUpdate.duration);
        }
        debouncedUpdateProgressBar();
      }
      
      function displayReceivedAmount(receivedAmount) {
        if (receivedAmount > 0) {
          const overlayText = `⚡ ${Math.round(receivedAmount)} sats ⚡`;
          satsReceivedOverlay.innerText = overlayText;
          
          gsap.fromTo(satsReceivedOverlay, 
            { opacity: 0, y: 20 }, 
            { 
              opacity: 1, 
              y: 0, 
              duration: animationConfig.satsReceivedOverlay.entryDuration,
              ease: "power2.out"
            }
          );

          setTimeout(() => {
            gsap.to(satsReceivedOverlay, { 
              opacity: 0, 
              y: -10, 
              duration: animationConfig.satsReceivedOverlay.exitDuration, 
              ease: "power2.in",
              onComplete: () => {
                updateSatsLeftDisplay(); 
              }
            });
          }, SATS_LEFT_DISPLAY_DURATION - (animationConfig.satsReceivedOverlay.exitDuration * 1000));
        } else {
          updateSatsLeftDisplay();
        }
      }
      
    function updateProgressBar() {
        if (isFeederAnimating) { 
            return;
        }

        const currentProgressVal = (goal > 0) ? (balance / goal) * 100 : 0;
        if (activeMessages.length > 0 && currentProgressVal < 100) { // If messages active AND not 100% yet
            return; 
        }

        if (goal === 0) {
            gsap.to(progressFill, { width: '0%', duration: animationConfig.progressBar.updateDuration / 1000 });
            progressFill.classList.remove('is-filling');
            progressFill.classList.remove('shine-effect'); 
            return;
        }

        const progress = Math.min(Math.max(currentProgressVal, 0), 100);

        if (progress < 100) { // Regular progress update
            gsap.to(progressFill, { 
                width: `${progress}%`, 
                duration: animationConfig.progressBar.updateDuration / 1000 
            });

            if (progress > 0) {
                if (!progressFill.classList.contains('is-filling')) {
                    progressFill.classList.add('is-filling');
                }
            } else {
                if (progressFill.classList.contains('is-filling')) {
                    progressFill.classList.remove('is-filling');
                }
            }
            progressFill.classList.remove('shine-effect');
        } else if (progress >= 100 && !isFeederAnimating) { // Goal reached!
            isFeederAnimating = true; 
            
            gsap.killTweensOf(progressFill, "width"); // Stop any message-driven width tweens

            gsap.to(progressFill, { width: '100%', duration: 0.2, onComplete: () => {
                const tl = gsap.timeline();
                tl.to(progressContainer, { 
                    scale: 1.05, 
                    duration: animationConfig.progressBar.popDuration / 2000, 
                    yoyo: true, 
                    repeat: 1, 
                    ease: "power1.inOut"
                })
                .to(progressFill, { 
                    backgroundColor: "#76FF03", 
                    duration: animationConfig.progressBar.colorFlashDuration / 2000, 
                    yoyo: true,
                    repeat: 1,
                    ease: "power1.inOut"
                }, "-=0.1") 
                .add(() => { 
                    progressFill.classList.remove('is-filling');
                    progressFill.classList.add('shine-effect');
                })
                .add(() => { 
                    triggerLightningEffect();
                    triggerFeederEffect(); 
                }, `+=${(animationConfig.progressBar.shineDuration / 1000) - 0.1}`);
            }});
        }
    }

    function triggerFeederEffect() { // No changes here
        feederTriggeredText.style.display = 'block'; 
        gsap.fromTo(feederTriggeredText,
          { opacity: 0, scale: animationConfig.feeder.scalingStart },
          { opacity: 1, scale: 1, duration: 0.5, ease: 'back.out(1.7)' });
        
        gsap.to(feederTriggeredText, {
          opacity: 0,
          scale: animationConfig.feeder.scalingEnd,
          duration: 0.5,
          delay: animationConfig.feeder.effectDuration / 1000 - 0.5, 
          ease: 'back.in(1.7)',
          onComplete: () => {
            feederTriggeredText.style.display = 'none'; 
            resetProgressBar(); 
          }
        });
    }

    function resetProgressBar() { // Modified to reset flag and re-evaluate messages
        balance = 0; 
        // updateSatsLeftDisplay(); // Called at the end of the timeline now

        gsap.set(progressDrainer, { display: 'block', width: '0%', right: '0', left: 'auto' });
        
        const tl = gsap.timeline({
            onComplete: () => {
                gsap.set(progressDrainer, { display: 'none' });
                isFeederAnimating = false; // Reset the flag here
                updateSatsLeftDisplay();   // Update display and potentially progress bar
                tryDisplayMessage();       // Allow messages to check if they can start
            }
        });

        tl.to(progressDrainer, { 
            width: '100%', 
            duration: animationConfig.progressBar.drainDuration / 1000,
            ease: "power1.inOut"
        })
        .to(progressFill, { 
            width: `0%`, 
            duration: animationConfig.progressBar.drainDuration / 1000 
        }, 0); 

        progressFill.classList.remove('is-filling');
        progressFill.classList.remove('shine-effect');
    }
      
      function addProcessedPaymentHash(hash) {
        if (processedPaymentHashes.size >= MAX_PROCESSED_HASHES) {
          const firstHash = processedPaymentHashes.values().next().value;
          processedPaymentHashes.delete(firstHash);
        }
        processedPaymentHashes.add(hash);
      }
      
      let ws;
      let currentReconnectInterval = RECONNECT_INTERVAL_BASE;
      
      function initWebSocket() {
        ws = new WebSocket(WS_URL);
        ws.onopen = () => { currentReconnectInterval = RECONNECT_INTERVAL_BASE; };
        ws.onerror = () => {};
        ws.onmessage = async (event) => {
          try {
            const data = JSON.parse(event.data);
            if (data.payment && data.wallet_balance !== undefined) {
              const receivedAmount = data.payment.amount / 1000;
              const walletBalanceSats = data.wallet_balance;
              const paymentHash = (data.payment.payment_hash || '').toLowerCase().trim();
              if (!paymentHash) return;
              if (processedPaymentHashes.has(paymentHash)) return;
              addProcessedPaymentHash(paymentHash);
              balance = walletBalanceSats;
              lastSuccessfulBalance = balance;
              if (receivedAmount > 0) {
                throttledUpdateSatsLeft(receivedAmount, true); 
                toggleQRCodeImage();
              } else if (receivedAmount < 0) { 
                throttledUpdateSatsLeft();
              }
            }
            if (data.message) {
              addMessageToQueue(data.message);
            }
          } catch (error) {}
        };
        ws.onclose = () => {
          setTimeout(() => {
            currentReconnectInterval = Math.min(currentReconnectInterval * 2, MAX_RECONNECT_INTERVAL);
            initWebSocket();
          }, currentReconnectInterval);
        };
      }
      
      let wsFastAPI;
      let reconnectIntervalFastAPI = 30000;
      
      function initWebSocketFastAPI() {
        wsFastAPI = new WebSocket(WS_URL_FASTAPI);
        wsFastAPI.onopen = () => { reconnectIntervalFastAPI = 30000; };
        wsFastAPI.onmessage = (event) => { handleFastAPIWebSocketMessage(event.data); };
        wsFastAPI.onerror = () => {};
        wsFastAPI.onclose = () => {
          setTimeout(initWebSocketFastAPI, reconnectIntervalFastAPI);
          reconnectIntervalFastAPI = Math.min(reconnectIntervalFastAPI * 2, 60000);
        };
      }
      
      function cleanMessageText(text) {
        if (!text) return '';
        let cleaned = text.replace(/[\r\n]+/g, ' ');
        cleaned = cleaned.replace(/https?:\/\/[^\s]+/g, '');
        cleaned = cleaned.replace(/www\.[^\s]+/g, '');
        cleaned = cleaned.replace(/\s+/g, ' ').trim();
        return cleaned;
      }

      function handleFastAPIWebSocketMessage(data) {
        try {
            if (data.trim().startsWith('{') && data.trim().endsWith('}')) {
            const jsonData = JSON.parse(data);
            if (jsonData.type === "connection_established") return;
            if (jsonData.type === "cyber_herd") {
                fetchSpotsRemaining(); 
                if(jsonData.members && Array.isArray(jsonData.members)) {
                    displayCyberHerdMembers(jsonData.members, jsonData.newest_pubkey || null);
                }
            }
            const messageText = jsonData.message;
            const cleanedMessage = cleanMessageText(messageText);
            addMessageToQueue(cleanedMessage);
            } else {
            const cleanedMessage = cleanMessageText(data);
            if (cleanedMessage) addMessageToQueue(cleanedMessage);
            }
        } catch (e) {
            const cleanedMessage = cleanMessageText(data);
            if (cleanedMessage) addMessageToQueue(cleanedMessage);
        }
      }
      
      class ImageCache {
        constructor(cacheName = 'lg-image-cache-v1') {
          this.cacheName = cacheName;
          this.cacheSupported = 'caches' in window;
          this.loadedImages = new Set(); 
        }
        async initCache() {
          if (!this.cacheSupported) return false;
          try {
            this.cache = await caches.open(this.cacheName);
            return true;
          } catch (error) { return false; }
        }
        async preloadImages(imageUrls) {
          if (!this.cacheSupported || !this.cache) return;
          const cachePromises = imageUrls.map(url => this.cacheImage(url, true));
          try { await Promise.allSettled(cachePromises); } catch (error) {}
        }
        async cacheImage(url, silent = false) {
          if (!this.cacheSupported || !this.cache || !url) return url;
          if (this.loadedImages.has(url)) return url;
          try {
            const cacheResponse = await this.cache.match(url);
            if (cacheResponse) { this.loadedImages.add(url); return url; }
            const fetchResponse = await fetch(url, { mode: 'no-cors', cache: 'no-cache' });
            if (fetchResponse && fetchResponse.status === 200) {
              await this.cache.put(url, fetchResponse.clone());
              this.loadedImages.add(url);
            }
            return url;
          } catch (error) { return url; }
        }
        async getImage(url) {
          if (!this.cacheSupported || !this.cache || !url) return url;
          try {
            const cachedResponse = await this.cache.match(url);
            if (cachedResponse) { this.loadedImages.add(url); return url; }
            await this.cacheImage(url);
            return url;
          } catch (error) { return url; }
        }
        async cleanCache(maxAgeDays = 7) {
          if (!this.cacheSupported) return;
          try {
            const cache = await caches.open(this.cacheName);
            const cachedRequests = await cache.keys();
            const now = Date.now();
            const maxAge = maxAgeDays * 24 * 60 * 60 * 1000;
            for (const request of cachedRequests) {
              const response = await cache.match(request);
              if (response) {
                const dateHeader = response.headers.get('date');
                if (dateHeader) {
                  const cacheDate = new Date(dateHeader).getTime();
                  if (now - cacheDate > maxAge) await cache.delete(request);
                }
              }
            }
          } catch (error) {}
        }
      }
      const imageCache = new ImageCache();
      
      function getPreloadImageUrls() {
        const urls = [];
        Object.values(goats).forEach(goat => { if (goat.img) urls.push(goat.img); });
        urls.push('images/qr.png', 'images/lightning.png', 'images/lightninggoatslogo1.png');
        return urls.filter(Boolean);
      }
      
      function createCachedImage(url, alt, title, options = {}) {
        const img = document.createElement('img');
        if (url && imageCache.cacheSupported) {
          if (options.placeholder) img.src = options.placeholder;
          imageCache.getImage(url).then(cachedUrl => { img.src = cachedUrl; })
                          .catch(() => { img.src = url; });
        } else { img.src = url; }
        if (alt) img.alt = alt;
        if (title) img.title = title;
        img.onerror = () => { img.src = options.fallback || "images/lightninggoatslogo1.png"; };
        return img;
      }
      
      function displayAccordion(items) {
        if (items.length > 0 && items[0].isUser) return true; 
        
        const accordionContainer = document.getElementById('accordion-container');
        accordionContainer.innerHTML = ""; 
        if (!items || items.length === 0) return false;
        
        items.forEach(item => {
          if (!item.imageUrl) return;
          const div = document.createElement('div');
          div.className = 'accordion-item';
          const content = document.createElement('div');
          content.className = 'accordion-content';
          const profileContainer = document.createElement('div');
          profileContainer.className = 'user-profile-container';
          const img = createCachedImage(item.imageUrl, item.name, item.name);
          profileContainer.appendChild(img);
          const textContainer = document.createElement('div');
          textContainer.className = 'user-profile-text';
          const nameElement = document.createElement('span');
          nameElement.className = 'user-profile-name';
          nameElement.innerText = item.name || "Goat";
          textContainer.appendChild(nameElement);
          profileContainer.appendChild(textContainer);
          content.appendChild(profileContainer);
          div.appendChild(content);
          accordionContainer.appendChild(div);
        });
        
        showAccordionContainer(true); 
        return true;
      }
      
      function toggleQRCodeImage() {
        gsap.to(qrCodeImg, {
          duration: animationConfig.qrCode.flashDuration / 1000,
          opacity: 0,
          onComplete: () => {
            qrCodeImg.style.display = 'none';
            lightningImg.style.display = 'block';
            gsap.to(lightningImg, { 
              duration: animationConfig.qrCode.flashDuration / 1000, 
              opacity: 1 
            });
          }
        });
        setTimeout(() => {
          gsap.to(lightningImg, {
            duration: 0.5,
            opacity: 0,
            onComplete: () => {
              lightningImg.style.display = 'none';
              qrCodeImg.style.display = 'block';
              gsap.to(qrCodeImg, { duration: 0.5, opacity: 1 });
            }
          });
        }, animationConfig.qrCode.displayDuration);
      }
      
      function updateCurrentTime() {
        const now = new Date();
        currentTimeElem.innerText = formatTime(now);
      }
      
      async function fetchTemperature() {
        try {
          const data = await fetchData(`${API_BASE_URL}/get_received_data`);
          const temp = data.AmbientWeatherWS2902A_WeatherDataWs2902a_Temperature;
          if (temp !== undefined) {
            const temperature = Math.round(temp);
            currentTempElem.innerText = `${temperature} °F`;
          }
        } catch (error) {}
      }
      
      function triggerLightningEffect() { // No changes here
        const lightningEffect = document.getElementById('lightning-effect');
        const bodyEl = document.body;

        lightningEffect.style.display = 'block';
        bodyEl.classList.remove('lightning-flash-on'); 

        let flashCount = 0;
        const flash = () => {
            if (flashCount >= animationConfig.lightning.flashCount) {
                lightningEffect.style.display = 'none';
                bodyEl.classList.remove('lightning-flash-on'); 
                return;
            }
            bodyEl.classList.add('lightning-flash-on');
            gsap.to(lightningEffect, {
                opacity: 1,
                duration: animationConfig.lightning.flashDuration / 2000, 
                onComplete: () => {
                    bodyEl.classList.remove('lightning-flash-on');
                    gsap.to(lightningEffect, {
                        opacity: 0,
                        duration: animationConfig.lightning.flashDuration / 2000, 
                        onComplete: () => {
                            flashCount++;
                            flash();
                        }
                    });
                }
            });
        };
        flash();
      }
      
      document.addEventListener('DOMContentLoaded', async function () {
        try {
          await imageCache.initCache();
          imageCache.preloadImages(getPreloadImageUrls());
          
          updateCurrentTime(); 
          satsLeftElem.innerText = `⚡Loading...⚡`;
          currentTempElem.innerText = `-- °F`;
          spotsRemainingElem.innerText = `CyberHerd spots left: --`;
          
          initWebSocket();
          initWebSocketFastAPI();
          
          const fetchPromises = [
            fetchGoal(),
            fetchBalance(),
            fetchSpotsRemaining(),
            fetchTemperature()
          ];
          await Promise.allSettled(fetchPromises);
          
          updateSatsLeftDisplay();
          
          setInterval(fetchTemperature, FETCH_INTERVAL);
          setInterval(updateCurrentTime, 1000);
          setTimeout(() => { imageCache.cleanCache(7); }, 60000); 
          
        } catch (error) {
          updateCurrentTime();
          satsLeftElem.innerText = `⚡Connect to see sats progress⚡`;
        }
      });

      const styleSheet = document.createElement("style");
      styleSheet.textContent = `
        #scrolling-comment .message-separator {
          color: ${animationConfig.message.separatorColor};
          font-weight: bold;
          margin: 0 10px;
          display: inline-block;
        }
      `;
      document.head.appendChild(styleSheet);
      
      function formatKinds(kinds) {
        if (!kinds) return "";
        let kindsArray = kinds;
        if (typeof kinds === 'string') {
          kindsArray = kinds.split(',').map(k => k.trim()).filter(k => k);
        }
        const kindLabels = { '6': '↻ Repost', '7': '❤️ Reaction', '9734': '⚡ Zap' };
        return Array.from(new Set(kindsArray)).map(kind => {
          const kindNum = String(kind).trim();
          return kindLabels[kindNum] || `Kind ${kindNum}`;
        }).join(' • ');
      }
      
      function displayCyberHerdMembers(members, newestPubkey = null) {
        if (!members || !Array.isArray(members) || members.length === 0) return false;
        
        const accordionContainer = document.getElementById('accordion-container');
        accordionContainer.innerHTML = ""; 
        
        const sortedMembers = members.sort((a, b) => (a.timestamp && b.timestamp) ? b.timestamp - a.timestamp : 0);
        const displayMembers = sortedMembers.slice(0, MAX_DISPLAYED_MEMBERS);
        
        displayMembers.forEach(member => {
          const pubkey = member.pubkey || "";
          const imageUrl = member.picture || member.imageUrl || "";
          const name = member.display_name || member.name || "Anon";
          const kinds = member.kinds || "";
          const amount = member.amount || 0;
          const isNewest = newestPubkey ? pubkey === newestPubkey : member.is_newest;
          
          if (!imageUrl) return;
          
          const div = document.createElement('div');
          div.className = 'accordion-item user-profile';
          const content = document.createElement('div');
          content.className = 'accordion-content user-profile';
          const img = createCachedImage(imageUrl, name, name, { fallback: "images/lightninggoatslogo1.png" });
          const profileContainer = document.createElement('div');
          profileContainer.className = 'user-profile-container';
          profileContainer.appendChild(img);
          const textContainer = document.createElement('div');
          textContainer.className = 'user-profile-text';
          const nameElement = document.createElement('span');
          nameElement.className = 'user-profile-name';
          nameElement.innerText = name;
          textContainer.appendChild(nameElement);
          if (kinds) {
            const kindsElement = document.createElement('span');
            kindsElement.className = 'user-profile-kinds';
            kindsElement.innerText = formatKinds(kinds); 
            textContainer.appendChild(kindsElement);
          }
          if (amount > 0) {
            const zapElement = document.createElement('span');
            zapElement.className = 'user-profile-zap';
            zapElement.innerText = `⚡ ${amount} sats`;
            textContainer.appendChild(zapElement);
          }
          profileContainer.appendChild(textContainer);
          content.appendChild(profileContainer);
          if (isNewest) {
            content.style.border = "2px solid #ffdb58";
            div.dataset.newest = "true";
          }
          div.appendChild(content);
          accordionContainer.appendChild(div);
        });
        
        showAccordionContainer(true); 
        return true;
      }
      
      function showAccordionContainer(staggerItems = false) {
        const accordionContainer = document.getElementById('accordion-container');
        if (accordionTimeout) clearTimeout(accordionTimeout);
        
        accordionContainer.style.display = 'flex';
        gsap.to(accordionContainer, {
          opacity: 1,
          x: 0, 
          duration: animationConfig.accordion.transitionDuration / 1000,
          onComplete: () => {
            if (staggerItems) {
                gsap.to(".accordion-item", {
                    opacity: 1,
                    duration: 0.5, 
                    stagger: animationConfig.accordion.itemStagger,
                    ease: "power1.out"
                });
            } else {
                gsap.set(".accordion-item", { opacity: 1 });
            }
          }
        });
        
        accordionTimeout = setTimeout(() => {
          gsap.to(accordionContainer, {
            opacity: 0,
            x: -100, 
            duration: animationConfig.accordion.transitionDuration / 1000,
            onComplete: () => {
              accordionContainer.style.display = 'none';
              gsap.set(".accordion-item", { opacity: 0 });
            }
          });
        }, animationConfig.accordion.displayDuration);
      }
    })();
  </script>
</body>
</html>
